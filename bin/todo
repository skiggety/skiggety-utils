#!/usr/bin/env python3.9
"""show TODO's in code (unless they say IGNORE_TODO on the same line, like this), sorted by votes"""

import sys
import os
import argparse
import stat
import re # regular expressions

# TODO^17: this breaks when you try to run from outside skiggety_utils, like when you run today_todo
# from your home dir:
from colorama import Fore, Back, Style

sys.path.append(os.path.abspath(os.path.join(os.getenv('SKIGGETY_UTILS_DIR'),"lib")))
#pylint: disable=C0413
from todo_line import TodoLine
#pylint: enable=C0413

# TODO: consider supporting an alternate format for votes, something that rubocop won't complain
# about

# TODO^3: accept piped-in grep output for sorting, like grep does
if sys.version_info[0] < 3:
    raise Exception('Must be using Python 3')

PROGRAM_DESCRIPTION = 'finds TODOs, sorted by votes'

def main():
    """Find and display todo entries, according to options passed in."""

    # TODO: use argparse built-in way of setting defaaults instead:
    ignore_keyword = None

    arg_parser = argparse.ArgumentParser(description = PROGRAM_DESCRIPTION)
    arg_parser.add_argument('-k', '--keyword',
            help = 'Select a keyword. Defaults to \'TODO\'.') # IGNORE_TODO
    # TODO: add_argument('-i', '--ignore-keyword', help = 'TODO')
    # TODO: add_argument('--interactive', action='store_true', help = 'TODO') # TODO: what's the one-character

    arg_parser.add_argument('--non-interactive', action='store_true', help = 'TODO') # TODO: what's the one-character version?
    arg_parser.add_argument('-w', '--write', action='store_true', help = 'TODO')
    arg_parser.add_argument('-f', '--force', action='store_true', help = 'TODO')
    arg_parser.add_argument('-d', '--debug', action='store_true', help = 'TODO')
    arg_parser.add_argument('-q', '--quiet', action='store_true', help = 'TODO')

    arg_parser.add_argument('--exclude-dir', help = 'Directories to exclude.', action = 'append')
    # TODO^2: support stuff like ' --exclude todo_report.gen.txt' starting with:
    # arg_parser.add_argument('--exclude', help = 'Directories to exclude.', action = 'append')

    command_line_args = arg_parser.parse_args()

    # set up condtions from command line arguments:

    exclude_dirs = command_line_args.exclude_dir or []
    keyword = command_line_args.keyword or 'TODO' # because you can use other keywords # IGNORE_TODO
    # TODO: use argparse built-in way of setting defaaults instead:
    ignore_keyword = ignore_keyword or f'IGNORE_{keyword}'
    # TODO: validate that the keywords can only be letters, underscores, and some basic stuff
    should_write = command_line_args.write
    should_force = command_line_args.force
    global should_debug # TODO: eliminate globals
    should_debug = command_line_args.debug
    quiet_mode = command_line_args.quiet

    # --non-interactive takes precendence until I figure out which one came last: (TODO: fix):
    interactive = True # TODO^2: check if output is to a terminal
    # TODO: interactive = command_line_args.interactive or interactive
    interactive = not command_line_args.non_interactive or interactive

    echo_debug('We are in debug mode (if you are seeing this message).')

    lines = []

    # TODO: refactor, too much nesting:
    for root, dirs, file_paths in os.walk('.', topdown=True):
        dirs[:] = [d for d in dirs if d not in exclude_dirs]
        for file_path in file_paths:
            full_file_path = os.path.join(root, file_path)
            if (stat.S_ISBLK(os.stat(full_file_path).st_mode) or
                stat.S_ISSOCK(os.stat(full_file_path).st_mode) ): # skip devices
                continue
            add_lines_from_file(lines, full_file_path, keyword, ignore_keyword)

    lines = sorted(lines, key = lambda l: (l.votecount, l.file_path, l.line_number))

    # TODO: method extract:
    if should_write:
        echo_debug('Ok, we should writing changes to disk...')
        if should_force:
            echo_debug('should_force = True')
        else:
            echo_debug('should_force = False')
        if interactive:
            echo_debug('interactive = True')
        else:
            echo_debug('interactive = False')
        if (should_force or (interactive and ask_user_to_confirm_file_writes())):
            echo_debug('Writing changes to disk...')
            for line in reversed(lines): # start with the highest-voted ones
                if line.has_changes_to_write():
                    echo_debug('There are changes to write for line: \'' + str(line) + '\'')
                    if (should_force or ask_user_to_confirm_this_line_write(line)):
                        line.write()
                else:
                    echo_debug('...skipping line with no changes')

    if not quiet_mode:
        for line in lines:
            print(str(line))

    # TODO^4: print summary with TODO count, maybe a vote count

# TODO: move to a new library:
def echo_debug(debug_message): # TODO: rename?
    if should_debug:
        # TODO: if you want, you could tie this into python's logging framework and do it that way
        sys.stderr.write(Fore.YELLOW + debug_message + '\n')
        sys.stderr.write(Style.RESET_ALL)

def ask_user_to_confirm_file_writes():
    return ask_user_yn('Would you like to write changes to files?')

def ask_user_to_confirm_this_line_write(line):
    return ask_user_yn('Would you like to replace \'' + line.original_text + '\' with \'' +
                       line.text + '\' at ' + line.file_path + ":" + str(line.line_number))

def ask_user_yn(question_text):
    full_question = question_text + ' [y/n]:'
    print(full_question, file=sys.stdout)
    answer = input()
    echo_debug('answer is \'' + answer + '\'')
    if answer.lower() in ["y","yes"]:
        echo_debug('...which means \'yes\'.')
        return True
    else:
        echo_debug('...which means \'no\'.')
        return False

def add_lines_from_file(lines, full_file_path, keyword, ignore_keyword):
    """given a file, collect relevant TodoLine's in lines"""

    # TODO^2: it is inefficient to re-create these every time, so make them an instance
    # variable:, once this is all in a class
    keyword_regex        = re.compile(keyword)
    ignore_keyword_regex = re.compile(ignore_keyword)

    # what happens with files of different encodings?
    #   TODO: make sure it works with files of different encodings
    #   TODO^2: shut up pylint (it wants me to specify an encoding)
    with open(full_file_path) as file:
        line_number = 0
        try:
            for line in file:
                line = line.rstrip('\n')
                line_number += 1
                if keyword_regex.search(line):
                    if not ignore_keyword_regex.search(line):
                        lines.append(TodoLine(keyword, full_file_path, line_number, line))
        except UnicodeDecodeError: # skip binary files
            pass

# TODO: flags:

  # TODO^5: make sure the last line is highlighted. It's the most important todo
  # and your attention should be drawn to it.
  # TODO^4: highlighting on or off. It should be on by default unless output is piped to a
  # file, like with grep and "--color" (or "--colour" )

    # TODO^3: highlight TODO's

  # TODO^3: todo should accept a path ( to a file or directory) to use in place of "." for grep.
  # This way you could run "todo bin/todo" and see the TODO^2's in this file cleanly without the
  # ingorable lines.

  # TODO^2: non-interactive [read-only] mode should be the default when this is called from a script
  # (output is not a tty)

  # TODO: add a command line option to specify a minimum number of votes, so if you pass
  # "--minimum-votes 3", "EXAMPLE_KEYWORD EXAMPLE_KEYWORD EXAMPLE_KEYWORD" or EXAMPLE_KEYWORD^3 will
  # show up, but not "EXAMPLE_KEYWORD EXAMPLE_KEYWORD"

  # TODO^11: when called from a terminal, this program should interactively check with the user if
  # they want to do replacements like "TODO TODO"-->"TODO^2" (IGNORE_TODO) before displaying sorted
  # output.

# TODO: consider spinning this project off, with a not-so-clever name like "tood" or something

main()

#!/usr/bin/env python3
"""show TODO's in code (unless they say IGNORE_TODO on the same line, like this), sorted by votes"""

import os
import platform
import sys
DESIRED_PYTHON_VERSION = '3.11.1'
if DESIRED_PYTHON_VERSION != platform.python_version():
    # limit recursion depth:
    os.environ['PYENV_VERSION_HACK_DEPTH'] = os.environ.get('PYENV_VERSION_HACK_DEPTH', '1')
    if int(os.environ.get('PYENV_VERSION_HACK_DEPTH', 1)) % 5 == 5: # avoid infinite loop
        raise Exception(f"Failed to force python version to {DESIRED_PYTHON_VERSION}. " \
                        "This script needs debugging.")
    os.environ['PYENV_VERSION'] = DESIRED_PYTHON_VERSION
    os.environ['PYENV_VERSION_HACK_DEPTH'] = str(int(os.environ['PYENV_VERSION_HACK_DEPTH']) + 1)
    home_dir = os.environ.get('HOME')
    # ugh, stack new shims on the path in case a parent process has already used pyenv to
    # stack on a specific python version's bin path:
    os.environ['PATH'] = f"{home_dir}/.pyenv/shims:{home_dir}/.pyenv/bin:{os.environ['PATH']}"
    os.execvpe(sys.argv[0], sys.argv, os.environ) # system exec self
os.environ['PYENV_VERSION_HACK_DEPTH'] = '0'

# TODO: figure out what's really the best way to nail down the python version, the hack above, or
# something simple like this in combination with packaging:
if sys.version_info[0] < 3:
    raise Exception('Must be using Python 3')

import argparse
import stat
import re # regular expressions

from colorama import Fore, Style

sys.path.append(os.path.abspath(os.path.join(os.getenv('SKIGGETY_UTILS_DIR'),"lib")))
#pylint: disable=C0413 # because this has to go after we mess with sys.path
from todo_line import TodoLine
#pylint: enable=C0413

# TODO: consider supporting an alternate format for votes, something that rubocop won't complain
# about

# TODO^3: accept piped-in grep output for sorting, like grep does

PROGRAM_DESCRIPTION = 'finds TODOs, sorted by votes' # IGNORE_TODO

def main():
    """Find and display todo entries, according to options passed in."""

    # TODO: use argparse built-in way of setting defaaults instead:
    ignore_keyword = None

    arg_parser = argparse.ArgumentParser(description = PROGRAM_DESCRIPTION)
    arg_parser.add_argument('-k', '--keyword',
            help = 'Select a keyword. Defaults to \'TODO\'.') # IGNORE_TODO

    # TODO: consider different single-letter extension, since -i is often used to mean
    # case-insensitive:
    # TODO: add_argument('-i', '--ignore-keyword', help = 'TODO')

    # TODO: how about an argument/mode for the linter that complains about non-compacted TODO
    # syntax, instead of writing or printing the normal report.
    arg_parser.add_argument('--non-interactive', action='store_true', help = 'TODO') # TODO: what's the one-character version?
    arg_parser.add_argument('-w', '--write', action='store_true', help = 'TODO')
    arg_parser.add_argument('-f', '--force', action='store_true', help = 'TODO')
    arg_parser.add_argument('-d', '--debug', action='store_true', help = 'TODO')
    arg_parser.add_argument('-q', '--quiet', action='store_true', help = 'TODO')

    # TODO: take a -v/--vote-for flag that takes a substring of a matching todo line and adds a vote for
    # it, compacts it, and that's it.

    arg_parser.add_argument('--exclude-dir', help = 'Directories to exclude.', action = 'append')
    # TODO^6: support stuff like ' --exclude todo_report/README.txt' starting with:
    arg_parser.add_argument('--exclude', help = 'Files to exclude.', action = 'append')

    command_line_args = arg_parser.parse_args()

    # above here, you just gotta print:
    global SHOULD_DEBUG
    SHOULD_DEBUG = command_line_args.debug
    echo_debug('We are in debug mode (if you are seeing this message).')

    # set up condtions from command line arguments:

    exclude_dirs = command_line_args.exclude_dir or []
    exclude_files = command_line_args.exclude or []
    exclude_files = [re.sub('^\.\/', '', i) for i in exclude_files]

    keyword = command_line_args.keyword or 'TODO' # because you can use other keywords # IGNORE_TODO
    # TODO: use argparse built-in way of setting defaaults instead:
    ignore_keyword = ignore_keyword or f'IGNORE_{keyword}'
    # TODO: validate that the keywords can only be letters, underscores, and some basic stuff
    should_write = command_line_args.write
    should_force = command_line_args.force
    quiet_mode = command_line_args.quiet

    global interactive # TODO: eliminate globals
    interactive = True # TODO^4: detect if output is to a terminal
    if command_line_args.non_interactive:
        interactive = False

    lines = []

    # TODO^2: parallelization might make this a lot faster (learn from rg)
    # TODO: refactor, too much nesting:
    for root, dirs, file_paths in os.walk('.', topdown=True):
        dirs[:] = [d for d in dirs if d not in exclude_dirs]
        for file_path in file_paths:
            full_file_path = os.path.join(root, file_path)
            if re.sub('^\.\/', '', full_file_path) in exclude_files:
                echo_debug(f"EXCLUDING FILE: {full_file_path}")
                continue
            if (stat.S_ISBLK(os.stat(full_file_path).st_mode) or
                stat.S_ISSOCK(os.stat(full_file_path).st_mode) ): # skip devices
                continue
            lines.extend(lines_from_file(full_file_path, keyword, ignore_keyword))

    lines = sorted(lines, key = lambda l: (l.votecount, l.file_path, l.line_number))

    # TODO: method extract:
    if should_write:
        echo_debug('Ok, we should be writing changes to disk...')
        echo_debug(f"should_force = {should_force}")
        echo_debug(f"interactive = {interactive}")
        if (should_force or interactive):
            echo_debug("considering writing files, no need to raise exception")
            if (should_force or (interactive and ask_user_to_confirm_file_writes())):
                echo_debug('Writing changes to disk...')
                for line in reversed(lines): # start with the highest-voted ones
                    if line.has_changes_to_write():
                        echo_debug('There are changes to write for line: \'' + str(line) + '\'')
                        if (should_force or (interactive and ask_user_to_confirm_this_line_write(line))):
                            # TODO^3: write more efficiently (all changes from one file at once):
                            line.write()
        else:
            raise Exception('Cannot write changes in non-interactive mode without the -f or ' \
                            '--force flag')

    if quiet_mode:
        echo_debug('skipping the report since we are in quiet mode')
    else:
        for line in lines:
            print(str(line))

    # TODO^4: print summary with TODO count, maybe a vote count

# TODO: move to a new library:
def echo_debug(debug_message): # TODO: rename?
    if SHOULD_DEBUG:
        # TODO: if you want, you could tie this into python's logging framework and do it that way
        sys.stderr.write(Fore.YELLOW + debug_message + '\n')
        sys.stderr.write(Style.RESET_ALL)
        sys.stdout.write(Style.RESET_ALL)

# TODO: maybe don't ask these questions as much, or only in a special mode, or DELETE entirely. See
# how it goes for now:
def ask_user_to_confirm_file_writes():
    """a high-level check of whether you want to write files at all"""
    return ask_user_yn('Would you like to write changes to files?')

def ask_user_to_confirm_this_line_write(line):
    """ask the user about individual lines to replace. Might be overkill, fine for now"""
    message = f"Would you like to replace this line:\n{line.original_text}\n" \
            f" ...with this line:\n{line.text}\n" \
            f" ...at this location?:\n{line.file_path}:{str(line.line_number)}\n"
    return ask_user_yn(message)

def ask_user_yn(question_text):
    """prompt the user with any yes or no question and return as a boolean"""
    if not interactive:
        raise Exception('cannot ask user questions in non-interactive mode')
    full_question = question_text + ' [y/n]:'
    sys.stdout.write(full_question)
    answer = input()
    echo_debug('answer is \'' + answer + '\'')
    if answer.lower() in ["y","yes"]:
        echo_debug('...which means \'yes\'.')
        return True
    echo_debug('...which means \'no\'.')
    return False

def lines_from_file(full_file_path, keyword, ignore_keyword):
    """given a file, collect relevant TodoLine's in lines"""

    lines_found = []

    # TODO^2: it is inefficient to re-create these every time, so make them an instance
    # variable:, once this is all in a class
    keyword_regex        = re.compile(keyword)
    ignore_keyword_regex = re.compile(ignore_keyword)

    # what happens with files of different encodings?
    #   TODO: make sure it works with files of different encodings
    #   TODO^2: shut up pylint (it wants me to specify an encoding)
    with open(full_file_path) as file:
        line_number = 0
        try:
            for line in file:
                line = line.rstrip('\n')
                line_number += 1
                if keyword_regex.search(line):
                    if not ignore_keyword_regex.search(line):
                        lines_found.append(TodoLine(keyword, full_file_path, line_number, line))
        except UnicodeDecodeError: # skip binary files
            pass
    return lines_found

# TODO: flags:

  # TODO^5: highlight TODO's
    # TODO^5: make sure the last line is highlighted. It's the most important todo
    # and your attention should be drawn to it.
    # TODO^5: highlighting on or off. It should be on by default unless output is piped to a
    # file, like with grep and "--color" (or "--colour" )

  # TODO^3: todo should accept a path ( to a file or directory) to use in place of "." for grep.
  # This way you could run "todo bin/todo" and see the TODO^2's in this file cleanly without the
  # ingorable lines.

  # TODO^2: non-interactive [read-only] mode should be the default when this is called from a script
  # (output is not a tty)

  # TODO: add a command line option to specify a minimum number of votes, so if you pass
  # "--minimum-votes 3", "EXAMPLE_KEYWORD EXAMPLE_KEYWORD EXAMPLE_KEYWORD" or EXAMPLE_KEYWORD^3 will
  # show up, but not "EXAMPLE_KEYWORD EXAMPLE_KEYWORD"

# TODO: consider spinning this project off, with a not-so-clever name like "tood" or something

main()

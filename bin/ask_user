#!/usr/bin/env bash

# This script asks the user to do the task described and report status back. It is a great way of stubbing out
# functionality.

# BONUS!!: I'm pretty sure it's also a shell/environment debugger. Just write something like this in your code (let's
# say a bash script but you could call it from other languages and inspect environment variables, technically):
#
#     for whatever in $___whatever_the_point_is_you_are_deep_in_code__; do
#         if ask_user "debug and decide whether you want to foo at $(echo_here)"
#         then
#             foo
#         else
#             definitely_do_not_foo
#         fi
#     done
#
# ...and then you can inspect, edit and run anything you need to, and, at the end, you get to control a binary switch
# because in some cases it's helpful to make a human decision a few times before you figure out how to teach^Wprogram
# the computer.


THIS_DIR="$(cd "$(dirname $BASH_SOURCE)";pwd)"
. $THIS_DIR/../lib/skiggety-utils.bash || exit 1

# TODO: I think something is getting eval'ed too many times, I'm trying to pass in TODO's and it's complainging about
# the syntax of what is supposed to be just text. Encountering this problem in ./silliness/live

debug_here "\$\* is: '$*'"
TASK_DESCRIPTION="$*"
debug_eval_here TASK_DESCRIPTION
ESCAPED_TASK_DESCRIPTION="$(echo "$TASK_DESCRIPTION" | sed 's/\("\)/\\\1/g')"
debug_eval_here ESCAPED_TASK_DESCRIPTION
banner='########################################################################'

# ding
tput bel

bash --rcfile <(cat ~/.bashrc; echo "PS1=\"${newline}$banner${newline}# TODO:${newline}# 1.) ${ESCAPED_TASK_DESCRIPTION}${newline}# 2.) Run \\\"exit 0\\\" for success/yes, or \\\"exit 1\\\" to say no/failure.${newline}$banner${newline}\$PS1\"") - # IGNORE_TODO
exit $?

#!/usr/bin/env python3
"""Demonstrates a hack that's fun but not a good idea"""

# This is just a salty little hack that allows a script to run itself in the python version of it's
# choice.  Probably a bad idea but I'm trying to be perhaps a little paranoid while I learn more
# about pyenv and packaging...

# WARNING: This is a bad idea because python can fail on syntax lower down if it doesn't recognize
# something from a newer version before it even runs the hack.  This happened to me with a
# match/case statement below a hack that was meant to get us to python 3.11.1 instead of 3.8 .

# Because the CURRENT directory should not determine the python version, which I think of as a
# property of the script itself:

# TO-NOT-DO: Once this works, use it everywhere.

# TODO: THIS SHOULD NOT BE NECESSARY! WHY? OH, WHY?!?! (maybe learn more about pyenv and how python
# scripts are normally packaged):
import os
import platform
import sys
import re # regular expressions, only for debug output
DESIRED_PYTHON_VERSION = '3.11.1'
print("DEBUG: ----------------------------------------")
print(f"DEBUG: sys.argv[0] is {sys.argv[0]}")
print(f"DEBUG: before touching version, os.environ.get('PYENV_VERSION') is {os.environ.get('PYENV_VERSION')}")
print("DEBUG: before touching version, os.environ.get('PYENV_VERSION_HACK_DEPTH') is "
      f"{os.environ.get('PYENV_VERSION_HACK_DEPTH')}")
print(f"DEBUG: before touching version, platform.python_version() is {platform.python_version()}")

print('DEBUG: the contents of $PATH breaks down to:')
path_as_array = os.environ.get('PATH').split(':')
for path_element in path_as_array:
    # showing home as ~ makes this easier to diff across different users and machines:
    print(re.sub(os.environ.get('HOME'), '~', f"    {path_element}"))

if DESIRED_PYTHON_VERSION != platform.python_version():

    # limit recursion depth:
    os.environ['PYENV_VERSION_HACK_DEPTH'] = os.environ.get('PYENV_VERSION_HACK_DEPTH', '1')
    print("DEBUG: after ||= 1, os.environ.get('PYENV_VERSION_HACK_DEPTH') is " \
          f"{os.environ.get('PYENV_VERSION_HACK_DEPTH')}")

    print("DEBUG: before modulo check, os.environ.get('PYENV_VERSION_HACK_DEPTH') is " \
          f"{os.environ.get('PYENV_VERSION_HACK_DEPTH')}")
    # This is hacky, but, if it works, whatever:
    if int(os.environ.get('PYENV_VERSION_HACK_DEPTH', 1)) % 5 == 5: # avoid infinite loop
        raise Exception(f"Failed to force python version to {DESIRED_PYTHON_VERSION}. " \
                        "This script needs debugging.")
    print(f"DEBUG: OK, attempting to switch from python version {platform.python_version()} to " \
          f"{DESIRED_PYTHON_VERSION}")
    print('setting PYENV_VERSION in env...')
    os.environ['PYENV_VERSION'] = DESIRED_PYTHON_VERSION
    print('incrementing PYENV_VERSION_HACK_DEPTH in env...')
    os.environ['PYENV_VERSION_HACK_DEPTH'] = str(int(os.environ['PYENV_VERSION_HACK_DEPTH']) + 1)
    print("DEBUG: after increment, os.environ.get('PYENV_VERSION_HACK_DEPTH') is " \
          f"{os.environ.get('PYENV_VERSION_HACK_DEPTH')}")
    print(f"DEBUG: os.environ.get('PYENV_ROOT') is {os.environ.get('PYENV_ROOT')}")
    pyenv_root_dir = os.environ.get('PYENV_ROOT')

    # TODO^2: is there something slightly cleaner I could do like run the child in a fresh login shell
    # or something to re-init pyenv?
    # ugh, stack new shims on the path in case a parent process has already used pyenv to
    # TODO: probably should only do this if pyenv shims are in the path somewhere
    # stack on a specific python version's bin path:
    print(f"DEBUG adding to front of path: {pyenv_root_dir}/shims:{pyenv_root_dir}/bin")
    os.environ['PATH'] = f"{pyenv_root_dir}/shims:{pyenv_root_dir}/bin:{os.environ['PATH']}"
    print(f"DEBUG: after setting version, os.environ.get('PYENV_VERSION') is {os.environ.get('PYENV_VERSION')}")
    os.execvpe(sys.argv[0], sys.argv, os.environ) # system exec self
    raise Exception("Should never get here.")
os.environ['PYENV_VERSION_HACK_DEPTH'] = '0'
print("DEBUG: after resetting to 0, os.environ.get('PYENV_VERSION_HACK_DEPTH') is " \
      f"{os.environ.get('PYENV_VERSION_HACK_DEPTH')}")
print("DEBUG: SUCCESS! (this is after version hack) If you cd to a different dir, will it still work?")

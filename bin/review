#!/usr/bin/env ruby
# frozen_string_literal: true

# TODO: possibly rename "delay" to sleep_interval or wait_time or something and use the language consistently.

# This program displays output of a given command and refreshes periodically.  By default, the delay is dynamic so you
# don't use up too many resources when nothing is changing but it is responsive when the output is changing.

# Ok, that's the dry version. Here's the real version. There's this common pattern where you have one window with your
# editor, and another terminal window where you run the thing. You know, whatever it is. It could be as simple as 'ls',
# but usually it's something like 'rspec spec/this/one/file.rb' or 'pylint <BLAH> <BLAH>' or 'do-my-usual-stuff.bash'.
# So, the point of 'review' is that it will manage that terminal window for you so you don't have to keep switching back
# and forth.  you run 'review my-command my commands args' and it takes care of running it over and over, so you don't
# have to.  Often 'my-command' would be a script you have open in your editor, so you really don't have to switch
# windows.

# For example, lets say you want to grep your text files for trailing spaces, you could do so with the command 'grep -RI
# " $" .', but it might be nice to keep running that command and updating a terminal with fresh output while you
# eliminate the trailing spaces in another terminal. In that case, prepend "review" to the command to get 'review grep
# -RI " $" .'. The grep will run repeatedly until you stop it, waiting a few seconds in between each run (this time will
# adjust automatically.

require 'English' # needed for: $CHILD_STATUS.exitstatus

require 'optparse'
require 'listen'

# TODO^3: would it be smart to have a cron job that runs 'pkill review' every day at ~7pm on my work laptop? Or should I
# instead strive to make the default behavior of this, and review-dev, so reasonable that it's not required? Also, can I
# make this exit gracefully when pkill runs (possibly with -HUP)?

# TODO: we might need a control key to wake it up and make it refresh immediately (accept a control character or signal
# to refresh now), but we might not need it now that we're 'listening' to the file system

# TODO: accept a flag to stop running if the wait gets longer than some specified amount
# TODO: accept log file that logs output, changes, frequencies/counts, etc.
# TODO: ensure we never mess with the colors, test with "review git diff"

# TODO: rubocop says this class is long (see .rubocop_todo.yml), is parse_args the part to extract?
class ReviewProgram

  def self.run
    new.run
  end

  def run
    parse_args
    cleanup_rbenv_influence

    command = ARGV.map{ |a| "\"#{a}\"" }.join(' ')

    @delay = minimum_delay

    @output = ''
    fill_screen_interactive(command)

    start_wake_on_filesystem_change # TODO^2: should this depend on a command line flag?

    while should_continue_looping(@exit_val) && wakeable_sleep_verbose(@delay)
      if @interactive
        fill_screen_interactive(command)
      else
        fill_screen_non_interactive(command)
      end
      change_detected = calc_change_detected
      adjust_delay!(change_detected, @ran_in_seconds)
    end
  end

  def parse_args
    # TODO: how about a flag to turn off screen clearing. I might like to run: review --no-clear -m 300 git pretty-pull

    # NOTE: this is an example of what NOT to do, because we need to distinguish between arguments that are meant for
    # this program, and arguments that are part of the command: $interactive = !ARGV.delete('--non-interactive')

    # turns out this is important so the rest of the options get left alone and passed on to the next comand:
    ENV['POSIXLY_CORRECT'] = 'true'

    @interactive = false
    OptionParser.new do |parser|
      parser.banner = "Usage: #{$PROGRAM_NAME} [options] command ..."
      parser.on('-h', '--help', 'show this help') do
        puts parser
        exit
      end
      parser.on('-m', '--min-delay MINIMUM', 'specify minimum delay in seconds') do |min|
        @min_delay = min.to_i
      end
      parser.on('-M', '--max-delay MAXIMUM', 'specify maximum delay in seconds') do |min|
        @max_delay = min.to_i
      end
      parser.on('-i', '--interactive', 'interactive mode') do
        @interactive = true
      end
      parser.on('-n', '--non-interactive', 'non-interactive (normal) mode') do
        @interactive = false
      end
    end.parse!(ARGV)

    # ...and I need to set it back or it screws up the output of pretty sleep and echo divider since they go back to the
    # beginning of the line
    ENV['POSIXLY_CORRECT'] = nil
  end

  # avoid forcing the same version of ruby on programs that this may call (be careful not to pass rbenv-related
  # environment variables down). Because it would be nice to be able to use "review dev" in other ruby projects
  # sometimes, like at work.
  def cleanup_rbenv_influence
    rbenv_root_dir = ENV.fetch('RBENV_ROOT', nil)
    ["#{rbenv_root_dir}/bin", "#{rbenv_root_dir}/shims"].each do |dir|
      path_as_array = ENV.fetch('PATH').split(':')
      ENV['PATH'] = "#{dir}:#{ENV.fetch('PATH')}" if path_as_array.include?(dir)
    end
    ENV['RBENV_VERSION'] = nil
    ENV['RBENV_DIR'] = nil
  end

  # TODO: probably rename these two "fill screen" methods, and maybe DRY the insides of them too:
  def fill_screen_interactive(command)
    time_command do
      @last_output = @output
      @last_exit_val = @exit_val
      system(command)
      @output = 'TODO: consider pulling some bs with tee to get the output'
      @exit_val = $CHILD_STATUS.exitstatus
    end
    show_footer(command)
  end

  def fill_screen_non_interactive(command)
    time_command do
      @last_output = @output
      @last_exit_val = @exit_val
      non_interactive_command = "#{command} 2>&1"
      @output = `#{non_interactive_command}`
      @exit_val = $CHILD_STATUS.exitstatus
    end
    system('clear')
    puts @output
    show_footer(command)
  end

  def time_command
    @last_start_timestamp = Time.now
    yield
    @last_end_timestamp = Time.now
    # TODO^3: maybe instead of using to_i, convert to decimal with 2-3 places:
    @ran_in_seconds = (@last_end_timestamp - @last_start_timestamp).to_i
  end

  # TODO: maybe skip files that are gitignored?:
  def start_wake_on_filesystem_change
    listener = Listen.to('.') do |_modified, _added, _removed|
      @wake_up_now = true if @wake_up_now == false
    end
    listener.start
  end

  def wakeable_sleep_verbose(delay)
    # TODO: think about how it would be nice to set @wake_up_now = false before the command runs to catch filesystem
    # changes during the command run, but the command you're running will often touch the filesystem so it may be not
    # practical:
    @wake_up_now = false
    delay = delay.to_i # just making sure, don't want to get confused
    delay_remaining = delay
    slept_already = 0
    while delay_remaining.positive? && @wake_up_now == false
      print "_...sleeping for #{delay_remaining}/#{delay} seconds...\033[0K\r"
      sleep 1
      delay_remaining -= 1
      slept_already += 1
    end
    print "_...slept for #{slept_already}/#{delay} seconds#{running_message}.#{woke_up_message}\033[0K\r"
    true
  end

  def woke_up_message
    @wake_up_now ? ' (WOKE UP on filesystem change)' : ''
  end

  def running_message
    @interactive ? '' : ', RUNNING again'
  end

  def calc_change_detected
    change_detected = true
    change_detected = false if @output == @last_output
    change_detected = true if @exit_val != @last_exit_val
    change_detected
  end

  # MULTIPLY_BY_DELAY has been dialed in based on real usage. There is no magic number. It should
  # always be greater than 1. Make it bigger to save cpu, and smaller to make this program more
  # responsive. Now that we wake up on filesystem changes, this can be a little bit larger:
  MULTIPLY_BY_DELAY = 1.25

  def adjust_delay!(change_detected, command_run_time)
    if change_detected
      @delay = minimum_delay
    else
      # Using command_run_time time in here means commands that take longer will backoff for longer, which seems
      # appropriate, since we can run quick things more often without using too much cpu/battery:
      add_to_delay = (command_run_time * 0.5).to_i + 1
      result = (MULTIPLY_BY_DELAY * @delay).floor + add_to_delay
      result = [result, @min_delay].max if @min_delay
      result = [result, @max_delay].min if @max_delay
      @delay = result
    end
  end

  DEFAULT_MINIMUM_DELAY = 1
  def minimum_delay
    @min_delay || DEFAULT_MINIMUM_DELAY
  end

  # TODO^3: colorize output, esp on failure:
  def show_footer(command)
    system("echo_divider_with_text \"#\" \"\\\"#{command}\\\" exited with #{@exit_val} after #{ran_in_seconds} " \
           "seconds at #{@last_end_timestamp}\"")
  end

  attr_reader :ran_in_seconds

  def should_continue_looping(last_exit_val)
    if loop_condition == 'always' || loop_condition.nil?
      true
    elsif loop_condition == 'success'
      last_exit_val.zero?
    elsif loop_condition == 'fail'
      !last_exit_val.zero?
    end
  end

  def loop_condition
    @loop_condition ||= ENV.fetch('REVIEW_WHILE', nil)
  end

end

ReviewProgram.run

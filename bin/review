#!/usr/bin/env ruby
# frozen_string_literal: true

# This program displays output of a given command and refreshes periodically.  By default, the delay is dynamic so you
# don't use up too many resources when nothing is changing but it is responsive when the output is changing.

# For example, lets say you want to grep your text files for trailing spaces, you could do so with the command 'grep -RI
# " $" .', but it might be nice to keep running that command and updating a terminal with fresh output while you
# eliminate the trailing spaces in another terminal. In that case, prepend "review" to the command to get 'review grep
# -RI " $" .'. The grep will run repeatedly until you stop it, waiting a few seconds in between each run (this time will
# adjust automatically.

require 'English' # needed for: $CHILD_STATUS.exitstatus

require 'optparse'

# TODO: would it be smart to have a cron job that runs 'pkill review' every day at ~7pm on my work laptop? Or should I
# instead strive to make the default behavior of this, and review-dev, so reasonable that it's not required? Also, can I
# make this exit gracefully when pkill runs (possibly with -HUP)?

# TODO^8: accept --interactive ("-i") or --non-interactive ("-n"), to determine whether to use backticks

# two about waking up:
# TODO^8: we need a control key to wake it up and make it refresh immediately (accept a
# control character or signal to refresh now)
# TODO^8: use the 'rerun' or 'listen'  gem to watch the filesystem and restart progrom when there are changes? maybe
# with a different command line option?

# TODO: accept a flag to stop running if the wait gets longer than some specified amount
# TODO: accept log file that logs output, changes, feequencies/counts, etc.
# TODO: ensure we never mess with the colors, test with "review git diff"

class ReviewProgram

  def self.run
    new.run
  end

  def run
    parse_args
    cleanup_rbenv_influence

    # TODO: the quotes in 'command' seem kind of excessive when you see them in the footer. How to safely/consistently
    # get rid of them:
    command = ARGV.map{ |a| "\"#{a}\"" }.join(' ')

    delay = @min_delay || 1

    time_command do
      system(command)
      @last_exit_val = $CHILD_STATUS.exitstatus
    end
    show_footer(command)

    @output = ''
    while should_continue_looping(@last_exit_val) && system("pretty_sleep -n #{delay}")
      time_command do
        @last_output = @output
        non_interactive_command = "#{command} 2>&1"
        @output = `#{non_interactive_command}`
        @last_exit_val = $CHILD_STATUS.exitstatus
      end

      system('clear')
      puts @output
      show_footer(command)

      change_detected = true
      change_detected = false if @output == @last_output
      delay = adjust_delay(delay, change_detected, @ran_in_seconds)
    end
  end

  def parse_args
    # TODO^3: non-interactive by default, intereactive mode for when the
    # program might prompt you with something, and in that case backticks
    # cannot be used:
    # TODO: how about a flag to turn off screen clearing. I might like to run: review --no-clear -m 300 git pretty-pull
    # NOTE: this is an example of what NOT to do, because we need to distinguish between arguments that are meant for
    # this program, and arguments that are part of the command: $interactive = !ARGV.delete('--non-interactive')

    # turns out this is important so the rest of the options get left alone and passed on to the next comand:
    ENV['POSIXLY_CORRECT'] = 'true'

    OptionParser.new do |parser|
      parser.banner = "Usage: #{$PROGRAM_NAME} [options] command ..."
      parser.on('-m', '--min-delay MINIMUM', 'specify minimum delay in seconds') do |min|
        @min_delay = min.to_i
      end
      parser.on('-M', '--max-delay MAXIMUM', 'specify maximum delay in seconds') do |min|
        @max_delay = min.to_i
      end
    end.parse!(ARGV)

    # ...and I need to set it back or it screws up the output of pretty sleep and echo divider since they go back to the
    # beginning of the line
    ENV['POSIXLY_CORRECT'] = nil
  end

  # avoid forcing the same version of ruby on programs that this may call (be careful not to pass rbenv-related
  # environment variables down). Because it would be nice to be able to use "review dev" in other ruby projects
  # sometimes, like at work.
  def cleanup_rbenv_influence
    rbenv_root_dir = ENV.fetch('RBENV_ROOT', nil)
    ["#{rbenv_root_dir}/bin", "#{rbenv_root_dir}/shims"].each do |dir|
      path_as_array = ENV.fetch('PATH').split(':')
      ENV['PATH'] = "#{dir}:#{ENV.fetch('PATH')}" if path_as_array.include?(dir)
    end
    ENV['RBENV_VERSION'] = nil
    ENV['RBENV_DIR'] = nil
  end

  def time_command
    @last_start_timestamp = Time.now
    yield
    @last_end_timestamp = Time.now
    # TODO^3: maybe instead of using to_i, convert to decimal with 2-3 places:
    @ran_in_seconds = (@last_end_timestamp - @last_start_timestamp).to_i
  end

  MULTIPLY_BY_DELAY = 1.10
  def adjust_delay(delay, change_detected, elapsed)
    if change_detected
      @min_delay || 1
    else
      # using elapsed time in here means commands that take longer will backoff for longer, which seems appropriate
      add_to_delay = ((elapsed * 0.5) + 1).to_i
      result = (MULTIPLY_BY_DELAY * delay).floor + add_to_delay
      result = [result, @min_delay].max if @min_delay
      result = [result, @max_delay].min if @max_delay
      result
    end
  end

  # TODO^3: colorize output, esp on failure:
  def show_footer(command)
    system("echo_divider_with_text \"#\" \"'#{command}' exited with #{@last_exit_val} after #{ran_in_seconds} " \
           "seconds at #{@last_end_timestamp}\"")
  end

  attr_reader :ran_in_seconds

  def should_continue_looping(last_exit_val)
    if loop_condition == 'always' || loop_condition.nil?
      true
    elsif loop_condition == 'success'
      last_exit_val.zero?
    elsif loop_condition == 'fail'
      !last_exit_val.zero?
    end
  end

  def loop_condition
    @loop_condition ||= ENV.fetch('REVIEW_WHILE', nil)
  end

end

ReviewProgram.run

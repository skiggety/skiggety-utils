#!/usr/bin/env ruby
# frozen_string_literal: true

# This program displays output of a given command and refreshes periodically.  By default, the delay is dynamic so you
# don't use up too many resources when nothing is changing but it is responsive when the output is changing.

# Ok, that's the dry version. Here's the real version. There's this common pattern where you have one window with your
# editor, and another terminal window where you run the thing. You know, whatever it is. It could be as simple as 'ls',
# but usually it's something like 'rspec spec/this/one/file.rb' or 'pylint <BLAH> <BLAH>' or 'do-my-usual-stuff.bash'.
# So, the point of 'review' is that it will manage that terminal window for you so you don't have to keep switching back
# and forth.  you run 'review my-command my commands args' and it takes care of running it over and over, so you don't
# have to.  Often 'my-command' would be a script you have open in your editor, so you really don't have to switch
# windows.

# For example, lets say you want to grep your text files for trailing spaces, you could do so with the command 'grep -RI
# " $" .', but it might be nice to keep running that command and updating a terminal with fresh output while you
# eliminate the trailing spaces in another terminal. In that case, prepend "review" to the command to get 'review grep
# -RI " $" .'. The grep will run repeatedly until you stop it, waiting a few seconds in between each run (this time will
# adjust automatically.

require 'English' # needed for: $CHILD_STATUS.exitstatus

require 'optparse'
require 'listen'
require 'colorize'

# TODO^3: would it be smart to have a cron job that runs 'pkill review' every day at ~7pm on my work laptop? Or should I
# instead strive to make the default behavior of this, and review-dev, so reasonable that it's not required? Also, can I
# make this exit gracefully when pkill runs (possibly with -HUP)?

# TODO: we might need a control key to wake it up and make it refresh immediately (accept a control character or signal
# to refresh now), but we might not need it now that we're 'listening' to the file system

# TODO: accept a flag to stop running if the wait gets longer than some specified amount
# TODO: accept log file that logs output, changes, frequencies/counts, etc.
# TODO: ensure we never mess with the colors, test with "review git diff"

# TODO: rubocop says this class is long (see .rubocop_todo.yml), is parse_args the part to extract?

# TODO: BUG watch out for this program pinning the cpu
# TODO^2: BUG make sure child processes get killed when you use CTRL + C on this program to stop it

class ReviewProgram

  def self.run
    new.run
  end

  attr_reader :ran_in_seconds

  def initialize
    @stop_on_failure = false
    @stop_on_success = false
    @slept_already = 0
    @should_clear_screen = true
    @interactive = false
    # TODO: min_delay, interactive, etc.
  end

  def run
    parse_args
    cleanup_rbenv_influence

    command = ARGV.map{ |a| "\"#{a}\"" }.join(' ')

    # TODO: possibly RENAME "delay" to sleep_interval or wait_time or something and use the terminology consistently.
    @delay = minimum_delay

    @output = ''
    fill_screen_interactive(command)

    start_wake_on_filesystem_change # TODO^2: should this depend on a command line flag?

    while wakeable_sleep_verbose(@delay)
      if @interactive
        fill_screen_interactive(command)
      else
        fill_screen_non_interactive(command)
      end
      change_detected = calc_change_detected
      adjust_delay!(change_detected)
    end
  end

  def exit_if_loop_condition_flag
    if @exit_val.zero?
      if @stop_on_success
        puts "'#{File.basename($PROGRAM_NAME)}' stopping on command success, was called with '--until'"
        exit(@exit_val)
      end
    elsif @stop_on_failure
      puts "'#{File.basename($PROGRAM_NAME)}' stopping on command failure, was called with '--while'"
      exit(@exit_val)
    end
  end

  # rubocop:disable Metrics/MethodLength
  def parse_args
    # NOTE: this is an example of what NOT to do, because we need to distinguish between arguments that are meant for
    # this program, and arguments that are part of the command: $interactive = !ARGV.delete('--non-interactive')

    # turns out this is important so the rest of the options get left alone and passed on to the next comand:
    ENV['POSIXLY_CORRECT'] = 'true'

    # rubocop:disable Metrics/BlockLength
    OptionParser.new do |parser|
      parser.banner = "Usage: #{$PROGRAM_NAME} [options] command ..."
      parser.on('-h', '--help', 'show this help') do
        puts parser
        exit
      end
      parser.on('-m', '--min-delay MINIMUM', 'specify minimum delay in seconds') do |min|
        @min_delay = min.to_i
      end
      parser.on('-M', '--max-delay MAXIMUM', 'specify maximum delay in seconds') do |min|
        @max_delay = min.to_i
      end
      parser.on('-i', '--interactive', 'interactive mode') do
        @interactive = true
      end
      parser.on('-n', '--non-interactive', 'non-interactive (normal) mode') do
        @interactive = false
      end
      parser.on('--while', 'keep looping only while commmand succeeds') do
        @stop_on_failure = true
      end
      parser.on('--until', 'keep looping only until commmand succeeds') do
        @stop_on_success = true
      end
      parser.on('--no-clear', "Don't clear the screen on each run") do
        @should_clear_screen = false
      end
    end.parse!(ARGV)
    # rubocop:enable Metrics/BlockLength

    # ...and I need to set it back or it screws up the output of pretty sleep and echo divider since they go back to the
    # beginning of the line
    ENV['POSIXLY_CORRECT'] = nil
  end
  # rubocop:enable Metrics/MethodLength

  # avoid forcing the same version of ruby on programs that this may call (be careful not to pass rbenv-related
  # environment variables down). Because it would be nice to be able to use "review dev" in other ruby projects
  # sometimes, like at work.
  def cleanup_rbenv_influence
    rbenv_root_dir = ENV.fetch('RBENV_ROOT', nil)
    ["#{rbenv_root_dir}/bin", "#{rbenv_root_dir}/shims"].each do |dir|
      path_as_array = ENV.fetch('PATH').split(':')
      ENV['PATH'] = "#{dir}:#{ENV.fetch('PATH')}" if path_as_array.include?(dir)
    end
    ENV['RBENV_VERSION'] = nil
    ENV['RBENV_DIR'] = nil
  end

  # TODO: probably RENAME these two "fill screen" methods, and maybe DRY the insides of them too:
  def fill_screen_interactive(command)
    time_command do
      @last_output = @output
      @last_exit_val = @exit_val
      system(command)
      @output = 'TODO: consider pulling some bs with tee to get the output'
      @exit_val = $CHILD_STATUS.exitstatus
    end
    show_footer(command)
    exit_if_loop_condition_flag
  end

  def fill_screen_non_interactive(command)
    time_command do
      @last_output = @output
      @last_exit_val = @exit_val
      non_interactive_command = "#{command} 2>&1"
      @output = `#{non_interactive_command}`
      @exit_val = $CHILD_STATUS.exitstatus
    end
    system('clear') if @should_clear_screen
    puts @output
    show_footer(command)
    exit_if_loop_condition_flag
  end

  def time_command
    @last_start_timestamp = Time.now
    yield
    @last_end_timestamp = Time.now
    # TODO^3: maybe instead of using to_i, convert to decimal with 2-3 places:
    @ran_in_seconds = (@last_end_timestamp - @last_start_timestamp).to_i
  end

  # TODO: maybe skip files that are gitignored?:
  def start_wake_on_filesystem_change
    listener = Listen.to('.') do |_modified, _added, _removed|
      @wake_up_now = true if @wake_up_now == false
    end
    listener.start
  end

  def wakeable_sleep_verbose(delay)
    # TODO: think about how it would be nice to set @wake_up_now = false before the command runs to catch filesystem
    # changes during the command run, but the command you're running will often touch the filesystem so it may be not
    # practical:
    @wake_up_now = false
    delay = delay.to_i # just making sure, don't want to get confused
    delay_remaining = delay
    @slept_already = 0
    while delay_remaining.positive? && (@slept_already < minimum_delay || @wake_up_now == false)
      print "_...sleeping for #{delay_remaining}/#{delay} seconds...\033[0K\r"
      sleep 1
      delay_remaining -= 1
      @slept_already += 1
    end
    print "_...slept for #{@slept_already}/#{delay} seconds#{running_message}.#{woke_up_message}\033[0K\r"
    true
  end

  def woke_up_message
    @wake_up_now ? ' (WOKE UP on filesystem change)' : ''
  end

  def running_message
    @interactive ? '' : ', RUNNING again'
  end

  def calc_change_detected
    change_detected = true
    change_detected = false if @output == @last_output
    change_detected = true if @exit_val != @last_exit_val
    change_detected
  end

  # MULTIPLY_BY_DELAY has been dialed in based on real usage. There is no magic number. It should
  # always be greater than 1. Make it bigger to save cpu, and smaller to make this program more
  # responsive. Now that we wake up on filesystem changes, this can be a little bit larger:
  MULTIPLY_BY_SLEPT_ALREADY = 0.25

  def adjust_delay!(change_detected)
    if change_detected
      @delay = minimum_delay
    else
      # Using ran_in_seconds time in here means commands that take longer will backoff for longer, which seems
      # appropriate, since we can run quick things more often without using too much cpu/battery:
      add_to_delay = (ran_in_seconds * 0.5).to_i + 1
      result = (@delay + (MULTIPLY_BY_SLEPT_ALREADY * @slept_already)).floor + add_to_delay
      result = [result, @min_delay].max if @min_delay
      result = [result, @max_delay].min if @max_delay
      @delay = result
    end
  end

  DEFAULT_MINIMUM_DELAY = 1
  def minimum_delay
    @min_delay || DEFAULT_MINIMUM_DELAY
  end

  # TODO: maybe format the timestamp differently, it's a little cluttered:
  # Now, in color!
  def show_footer(command)
    system("echo_divider_with_text \"#\" \"\\\"#{command}\\\" exited with #{red_unless_zero(@exit_val)} after " \
           "#{ran_in_seconds} seconds, having started at " + rotate_rainbow(@last_start_timestamp) + '"')
  end

  def red_unless_zero(text)
    text = text.to_s
    if text == '0'
      text
    else
      text.light_red
    end
  end

  def rotate_rainbow(text)
    @rainbow_colors ||= %i[light_yellow light_red light_magenta light_blue light_cyan light_green]
    @rainbow_index ||= rand(@rainbow_colors.size)
    color_method_name = @rainbow_colors[@rainbow_index]

    @rainbow_index += 1
    @rainbow_index %= @rainbow_colors.size

    text.to_s.send(color_method_name)
  end

end

ReviewProgram.run

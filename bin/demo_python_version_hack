#!/usr/bin/env python3
"""Demonstrates a hack, that may not even be a good idea, that allows a python script to
self-determine its version using pyenv."""

# TODO^19: (calling this "CFPVOM" bug because "cannot force python version on metrigon") Why the
# hell doesn't this hack work on metrigon (one of my macs)? It's setting the variable, but somehow pyenv
# is not doing the right thing. AHA! on metrigon, the specific python version is determined by $PATH
# before it can get to the shim the first time this runs, likely because of the "pyenv exec" that
# happens in the shim. This would not happen if we made a shell script that set PYENV_VERSION and
# called a renamed version ("todo_impl") of this script, so at some point we could give up and do
# that instead.

# TODO^17: DELETE many, but not all of the debug messages once "CFPVOM" bug is solved.

# Because the CURRENT directory should not determine the python version:
# TODO: THIS SHOULD NOT BE NECESSARY! WHY? OH, WHY?!?! (maybe learn more about pyenv and how python
# scripts are normally packaged):
import os
import platform
import sys
DESIRED_PYTHON_VERSION = '3.11.1'
print(f"DEBUG: ----------------------------------------")
print(f"DEBUG: sys.argv[0] is {sys.argv[0]}")
print(f"DEBUG: before touching version, os.environ.get('PYENV_VERSION') is {os.environ.get('PYENV_VERSION')}")
print('TODO^38: make sure this is false on the first run:')
print(f"DEBUG: before touching version, os.environ.get('PYENV_VERSION_HACKED') is {os.environ.get('PYENV_VERSION_HACKED')}")
print('...well, no wonder it works on eelwright...this is not a good test, apparently')
print(f"DEBUG: before touching version, platform.python_version() is {platform.python_version()}")
# print(f"DEBUG: before touching version, os.environ.get('PATH') is {os.environ.get('PATH')}")

# TODO^21: (part of solving CFPVOM bug) why does the PATH have the wrong version python bin in it if
# called from outside skiggety-utils? I think that is only supposed to happen if you call pyenv
# exec. UPDATE: I noticed pyenv exec IS being used in the pyenv shim, so why does this work at all
# on eelwright? maybe set PYENV_DEBUG to true and test that way. Another idea would be to rip it out
# of the path before exec, or get a fresh path using a new login shell or calling eval on python
# init. I dunno. It sounds pretty desperate.:

print('DEBUG: the contents os $PATH breaks down to:')
path_as_array = os.environ.get('PATH').split(':')
for path_element in path_as_array:
    print(f"    {path_element}")

if DESIRED_PYTHON_VERSION != platform.python_version():
    if os.environ.get('PYENV_VERSION_HACKED') == 'true': # avoid infinite loop
        raise Exception(f"Failed to force python version to {DESIRED_PYTHON_VERSION}. " \
                        "This script needs debugging.")
    print(f"DEBUG: OK, attempting to switch from python version {platform.python_version()} to {DESIRED_PYTHON_VERSION}")
    print('setting PYENV_VERSION in env...')
    os.environ['PYENV_VERSION'] = DESIRED_PYTHON_VERSION
    print('setting PYENV_VERSION_HACKED in env...')
    os.environ['PYENV_VERSION_HACKED'] = 'true'
    print(f"DEBUG: os.environ.get('HOME') is {os.environ.get('HOME')}")
    home_dir = os.environ.get('HOME')
    print(f"DEBUG: home_dir is {home_dir}")
    # TODO^37: try stacking a new shim on the path:
    print(f"DEBUG maybe add to path, if you can confirm they exist: {home_dir}/.pyenv/shims:{home_dir}/.pyenv/bin:...")
    print(f"DEBUG: after setting version, os.environ.get('PYENV_VERSION') is {os.environ.get('PYENV_VERSION')}")
    os.execvpe(sys.argv[0], sys.argv, os.environ) # system exec self

print(f"DEBUG: SUCCESS! (this is after version hack) If you cd to a different dir, will it still work?")
os.environ['PYENV_VERSION_HACKED'] = 'false'

#!/usr/bin/env bash

# This script asks the user to do something as part of firstlife

# EASY TODO^88: use this script widely in firstlife instead of shellask
# TODO: maybe keep track of what time of day tasks by certain names get completed, so you can start showing information
# about how long things should take

. $SKIGGETY_UTILS_DIR/lib/skiggety-utils.bash || exit 1
. $SKIGGETY_UTILS_DIR/lib/firstlife.bash || exit_with_error 'could not use common firstlife code'

WITH_REWARD='false'
while [[ "$1" == -* ]]; do
    # FUN TODO^40: --pester-after-seconds n # probably will have to fork off a watcher process
    if [[ "$1" == '--with-reward' ]]; then # TODO^10: take --without-reward instead
        WITH_REWARD='true'
        shift
    else
        exit_with_error "unrecognized option: '$1'"
    fi
done

# TODO^20: in a separate shell we don't wait for, wait a minute and then open a video reminding them they have an open # shellask
# TODO^51: shellask --alert, inside it try something like ''osascript -e 'display notification "Done!" with title "Long-running shell command" sound name "Hero"' like you saw at 'https://stackoverflow.com/questions/40814932/is-there-a-way-to-bring-terminal-to-front-when-command-is-finished', to bring window to foreground, especially after popping a web page, and do something similar in firstlife-reward if it works:
# - TODO^38: use mplayer in a loop to play something incessantly until you shut it up, optionally
# TODO: test with different input, quoted or not:
shellask "$*" || exit_with_error "$0 FAILED to do: $*" # EASY TODO^67: TEST exit_with_error

if $WITH_REWARD; then
    firstlife-reward "$*" # no error checking
fi

exit 0

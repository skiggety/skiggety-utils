#!/usr/bin/env bash

# TODO: make this a printable help message:
# "grim" is GRep into vIM. It is a handy way to find instances of a keyword
# (with grep) across a directory tree, and then open those files at the right
# location with vim. For example, if you run "grim gobbledygooklkajsdfoine", it
# should bring you right here.

#TODO?: VIM_OPTIONS=""
GREP_OPTIONS="-Rl"
VIM_SEARCH_STRING_SUFFIX=""

while [[ "$1" == -* ]]; do
    if [ "$1" == "-i" ]; then
        GREP_OPTIONS="$GREP_OPTIONS $1"
        VIM_SEARCH_STRING_SUFFIX="\c"
        shift
    elif [[ "$1" == --exclude* ]]; then
        GREP_OPTIONS="$GREP_OPTIONS $1 $2"
        shift
        shift
    else
        echo "ERROR: option not supported: $1" >&2
        echo "TODO: IMPLEMENT" >&2; exit 1
    fi
done

if [ -z "$*" ];then
    echo "ERROR: no arguments passed to $(basename $0)" >&2
    exit 1
fi

GRIM_TARGET_STRING="$1"; shift

# TODO: DELETE?
if ! [ -z "$*" ]; then
    echo "ERROR: no flags allowed after search string"
    exit 1
fi
echo GRIM_TARGET_STRING is: $GRIM_TARGET_STRING

# TODO TODO: don't open vim swap files, in fact, maybe no hidden files at all
GRIM_FILES=`grep $GREP_OPTIONS "$GRIM_TARGET_STRING" .|grep -v .swp\$`
echo GRIM_FILES are: $GRIM_FILES

# TODO: Maybe other arguments passed in can be sent to vim, so you can to gvim or -O
# TODO: what if a regex gets passed in? can you get the same one to work for grep and vim?
if [ -z "$GRIM_FILES" ]
then
    echo No files to open!
else
    vim -on $GRIM_FILES +/"$GRIM_TARGET_STRING$VIM_SEARCH_STRING_SUFFIX" # TODO: support readonly vim mode by passing a "-R" flag if this program recieves a "-R"
    echo DEBUG: ran: vim -Ron $GRIM_FILES +/"$GRIM_TARGET_STRING$VIM_SEARCH_STRING_SUFFIX"
fi

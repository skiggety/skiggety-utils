./Dockerfile:15:# TODO: ideally skiggety utils should handle this:
./Dockerfile:56:# TODO: RUN echo "install-skiggety-utils;less README.md;dev" >> /root/.bashrc
./Dockerfile:58:# TODO: set up something helpful to display on the screen when the user logs in with bash
./PWD_BIN/ci:10:#  # TODO: one idea is that 'ci' is something very high level that uses review heavily but probably uses it once to wait
./PWD_BIN/ci:16:# TODO: I think this script should save the output of dev and simply cat it if there is no update from git
./PWD_BIN/ci:31:# TODO: ???: git restore --staged .
./PWD_BIN/ci:40:# SKIGGETY_DEBUG=true # TODO: come up with a format like what I have but with a timestamp and author included, then save
./PWD_BIN/dashboard:28:# TODO?: tell you what command to run to commit changes or whatever
./PWD_BIN/dashboard:29:# TODO?: graph score over time (see program "progress")
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:3:# This script (...TODO, describe your script here)
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:15:while [ $test_num -lt 10 ]; do # TODO: add zeros
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:18:        SKIGGETY_BLINKY_DEBUG=true # TODO: put this right above where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:20:        SKIGGETY_BLINKY_DEBUG=false # TODO: put this right below where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:23:        SKIGGETY_BLINKY_DEBUG=true # TODO: put this right above where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:25:        SKIGGETY_BLINKY_DEBUG=false# TODO: put this right below where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:27:        # TODO: LOG ERROR!!!
./PWD_BIN/dev:6:# TODO: ci has to be able to call this in read-only mode
./PWD_BIN/dev:8:# TODO: in bin/, should there be a dev and a default-dev like with dashboard?
./PWD_BIN/generate_todo_report:3:# TODO: specify to abbreviate in terms of how many todo's to show (3) instead of how many lines to take up on the
./PWD_BIN/generate_todo_report:20:todo_report_body="$(echo "$todo_report_whole" | abbreviate -n $TODO_REPORT_LINES -t 'todo' )"
./PWD_BIN/generate_todo_report:21:todo_report_body_in_color="$(echo "$todo_report_whole_in_color" | abbreviate -n $TODO_REPORT_LINES -t 'todo' )"
./PWD_BIN/generate_todo_report:28:echo "$todo_report_whole" > $TODO_MASTER_LIST
./PWD_BIN/generate_todo_report:29:echo "$todo_header" > $TODO_REPORT_FILE
./PWD_BIN/generate_todo_report:30:echo "$todo_header" > $TODO_REPORT_COLOR_FILE
./PWD_BIN/generate_todo_report:31:echo "$todo_report_body" >> $TODO_REPORT_FILE
./PWD_BIN/generate_todo_report:32:echo "$todo_report_body_in_color" >> $TODO_REPORT_COLOR_FILE
./PWD_BIN/generate_todo_report:34:cat $TODO_REPORT_COLOR_FILE
./PWD_BIN/install-skiggety-utils:19:# TODO: install and configure 3rd party programs
./PWD_BIN/install-skiggety-utils:22:    # TODO?: install kubernetes
./PWD_BIN/install-skiggety-utils:23:    # TODO: install/config chrome tab scheduler and/or other stuff to enable a some kind of dashboard in a web browser
./PWD_BIN/install-skiggety-utils:24:    # TODO: install moreutils (http://joeyh.name/code/moreutils/)?
./PWD_BIN/install-skiggety-utils:25:    # TODO: install pocket
./PWD_BIN/install-skiggety-utils:39:    # TODO: add an option to reinstall, meaning delete installers/.markers/*_with_version* first
./PWD_BIN/install-skiggety-utils:40:    #   TODO: have update-skiggety-utils support this option, too
./PWD_BIN/install-skiggety-utils:46:            "h") exit_with_error "TODO: print usage" ;;
./PWD_BIN/install-skiggety-utils:47:            "?") exit_with_error "TODO: print usage" ;;
./PWD_BIN/install-skiggety-utils:57:        # TODO: make sure that when you run "review install-skiggety-utils", this is in non-interactive mode:
./PWD_BIN/lint:35:# TODO: call rupocop with -a OR -P depending on whether this script is in write mode or not (this script should have
./PWD_BIN/review-ci:7:# TODO: consider splitting to default_ and normal version like dashboard and lint
./PWD_BIN/skiggety-skip-installer:1:# TODO: something like: touch installers/.markers/.skip.$1
./PWD_BIN/unit-test:5:# TODO: make output more concise, it takes up a lot of screen space when running 'review-dev' (or 'dev').  Maybe show
./PWD_BIN/unit-test:9:THIS_DIR="$(cd "$(dirname $BASH_SOURCE)";pwd)" # TODO: DELETE?
./PWD_BIN/unit-test:14:# TODO: complain if install-skiggety-utils needs to be run
./PWD_BIN/unit-test:21:# TODO: ./test/test_todo_v0.4.bash || accumulate_error "shell integration tests for 'todo_v0.4' FAILED"
./PWD_BIN/unit-test:42:run_all_python_tests || accumulate_error "Python tests FAILED" # TODO: run ALL python tests"
./README.md:131:  - TODO: "playbot", a program that tunes in youtube livestreams, video meetings, watch later, podcasts and your personal dashboards, automatically. Great as an information radiator.
./README.md:132:  - TODO: something to keep randomized youtube playlists playing without interruption for music and such
./README.md:133:  - TODO: 'rod' would be a good name for a transparent screen locker. It would stand for "Read-Only Display"
./README.md:140:  - TODO: consider trying/supporting fish
./README.md:147:  - TODO: find a tool that can show graphs of provided data on the command line
./README.md:151:  - TODO: set up router
./README.md:155:- TODO: systematized config (automate the configuration I always want anyway)
./README.md:159:- TODO: document usage of commands
./README.md:160:- TODO: help set up home data center?
./README.md:161:- TODO: put a directory in skigg-utils that contains reference/demo code that shows you how to do certain things
./README.md:162:- TODO: implement ratcheting that can be used for code coverage, number of intstances of a string, number of lint failures, etc. It should be usable as part of a pre-merge hook for git and/or blocking a github pull request
./README.md:163:- TODO: is there a way to commit TODO's somewhere other than local, but not show them publicly on github (I have gitignore files available, but a branching convention might be ghood for keeping them in code)?
./README.md:164:- TODO: An [opinionated] tool for automatically seeding/templating new projects
./README.md:165:- TODO: utility for timestamping [log] output like this: https://serverfault.com/questions/310098/how-to-add-a-timestamp-to-bash-script-log
./README.md:166:- TODO?: gol - Short for "Git Off my Lawn", this would be an opinionated command-line front end for git.
./bin/abbreviate:23:    # TODO: help option should explain that -n tells it how many lines of screen space to use, including the explanation
./bin/chbs:21:  # TODO: consider a --dense (a.k.a. --troubador a.k.a. -d) mode to generate secure passwords in the traditional style
./bin/chbs:24:  # TODO: maybe accept a flag that makes this print one and only one passphrase, with no other output.  It could be used
./bin/chbs:32:    # TODO: # consider (optionally? If there's an internet connection) using the
./bin/chbs:33:    # TODO: # EFF word list:
./bin/chbs:34:    # TODO: # https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt
./bin/chbs:101:    4 # TODO: UN-HARDCODE
./bin/chbs:105:    10 # TODO: UN-HARDCODE
./bin/chbs:124:    # TODO: make this optional
./bin/dashboard:5:# TODO: some convenience for copying this to start a new dashboard (for some other project).  Something like:
./bin/default_dashboard:2:# TODO: consider #!/usr/bin/env python3 OR #!/usr/bin/env ruby
./bin/default_dashboard:25:# TODO: why is this producing so much output lately, like in content manager, even when there have only been a few
./bin/default_dashboard:33:# TODO: this shows a more complete diff, including new files...do I want to use it instead?: for next in $( git ls-files --others --exclude-standard ) ; do git --no-pager diff --no-index /dev/null $next; done; # git diff
./bin/duh:7:COLOR1='' # TODO
./bin/duh:8:COLOR2='' # TODO
./bin/duh:9:COLOR3='' # TODO
./bin/firstlife:15:# TODO: if a second firstlife pops up, maybe it should take over and the old one gracefully exits?
./bin/firstlife:37:# TODO: exit_if_another_terminal_took_over
./bin/firstlife:38:# - TODO: ultimately, combine for exit_if_another_terminal_or_day_took_over_with_accumulated_errors
./bin/firstlife:49:update_todo_graph # TODO: only if using today_todo
./bin/firstlife-break:3:# This script (...TODO, describe your script here)
./bin/firstlife-check-calendar:7:open 'https://www.google.com/calendar/render' # TODO: UN-HARDCODE
./bin/firstlife-delegate:6:# TODO: maybe keep track of what time of day tasks by certain names get completed, so you can start showing information
./bin/firstlife-delegate:25:# TODO: test with different input, quoted or not:
./bin/firstlife-evening:30:firstlife-delegate --with-reward 'find your book' || accumulate_error "You don't even know where your book is" # TODO?: MOVE to the inner routine
./bin/firstlife-focus:3:# This script (TODO...)
./bin/firstlife-pomodoro:7:# TODO?: maybe accept a '--without-reward' option
./bin/firstlife-pomodoro:11:# TODO: or should this be done right in ther terminal with sleep-verbose? instead of youtube and shellask:
./bin/firstlife-pomodoro:18:# TODO: or should this be a 5-minute timer from youtube?:
./bin/firstlife-pomodoro:19:# TODO: break should be optional with '--without-break' or some such switch
./bin/firstlife-reward:18:# TODO?: we need a custom video: ding-toaster
./bin/firstlife-reward:26:# TODO?: DELETE?: shellask "$request" # no error checking on purpose
./bin/firstlife-reward:61:# TODO?: (after above) || firstlife-save-reward-for-later
./bin/firstlife-single-alarm:3:# This script (...TODO, describe your script here)
./bin/firstlife-wake:19:#   - TODO: make sure volume is up
./bin/firstlife-work:3:# This script (TODO...)
./bin/git-attempt-merge:3:# TODO: IMPLEMENT: like git-attempt-checkout, but for merge
./bin/git-log-recent:7:# TODO: default to 3 and take an '-n' option:
./bin/git-object-to-added-keyword:17:    # TODO: echoing the line number this is coming from is distracting:
./bin/git-push-new-branch:4:# TODO: capture output and open browser to new pull request automatically
./bin/git-ready:11:        # TODO: -m "commit comment"
./bin/git-ready:27:    # TODO: just exit 0 right here unless there are changes staged (yes, we're checking again because the user might
./bin/grim:32:        echo "TODO: IMPLEMENT more passthrough options for vim or grep?" >&2; exit 1
./bin/grim:43:# TODO: DELETE?
./bin/grim:49:# TODO: rip out old grep?
./bin/grim:54:# TODO: Maybe other arguments passed in can be sent to vim, so you can to gvim or -O
./bin/grim:55:# TODO: what if a regex gets passed in? can you get the same one to work for grep and vim?
./bin/hesitate-and-run:5:# TODO: ask-to-run could be a similar script, using shellask and used by today_todo & ./start
./bin/lint:5:# TODO: split into default_lint and lint like with dashboard
./bin/misc_lint:5:exit_with_error "TODO: IMPLEMENT..."
./bin/misc_lint:6:# TODO: complain if PWD_BIN/dev is too long (use wc)
./bin/newbin:5:# TODO: DRY functionality with vimwhich, there is or at least should be some overlap.  Maybe vimwhich should call newbin
./bin/newbin:32:    # TODO: frozen string literal thingy if ruby
./bin/newbin:35:        # TODO: copy a template file:
./bin/psbranch:8:# TODO: implement --help option
./bin/psbranch:9:# TODO: implement option to only show current branch, maybe use it from shellask when debugging firstlife so you can see # where you are
./bin/psbranch:21:    # TODO: command line switch to show only what' in your one terminal bypassing $YOUNG_ANCESTOR instead of
./bin/psbranch:86:# TODO: DEBUG why this returns multiple users sometimes (try passing 0)
./bin/review-dev:4:# TODO: consider renaming this to template_review-dev or default something
./bin/review_v0.1:50:# TODO: BUG watch out for this program pinning the cpu
./bin/review_v0.1:51:# TODO: accept log file that logs output, changes, frequencies/counts, etc.
./bin/review_v0.1:52:# TODO: ensure we never mess with the colors, test with "review git diff"
./bin/review_v0.1:54:# TODO: rubocop says this class is long (see .rubocop_todo.yml), is parse_args the part to extract?:
./bin/review_v0.1:64:    # TODO: minimum_delay, etc.
./bin/review_v0.1:81:    @delay = minimum_delay # TODO: we don't have to start with the minimum, we could take a flag
./bin/review_v0.1:131:      # TODO: have a flag that lets you specify which path on the filesystem to listen to.
./bin/review_v0.1:133:      # - TODO: Probably ought to then have a flag to set that multiplier.
./bin/review_v0.1:135:      # TODO: --timeout <n>, or in other words kill commands after this many seconds..
./bin/review_v0.1:136:      # TODO: should be able to specify min/max delay from the command line as hh:mm:ss if you want:
./bin/review_v0.1:246:    # TODO: think about how it would be nice to set @wake_up_now = false before the command runs to catch filesystem
./bin/scratch:5:# TODO?: move to 'kid-utils'?
./bin/shellask:6:# TODO?: rename "shellegate"? (something called 'shellask' could accept more than boolean response maybe)
./bin/shellask:30:#     TODO: figure out roughly what % of the time it happens, maybe with a test harness that repeats and logs 1000 times
./bin/shellask:33:SKIGGETY_DEBUG=true # TODO: DELETE once shellask sets the prompt reliably
./bin/shellask:40:# TODO?: debug_eval_here ESCAPED_TASK_DESCRIPTION
./bin/shellask:44:# TODO?: debug_eval_here DOUBLE_ESCAPED_TASK_DESCRIPTION
./bin/shellask:52:# TODO: should I quiet this down, quiet optionally, what? maybe firstlife can alert and this should abstain?:
./bin/shellask:55:# TODO?: debug_eval_here TASK_DESCRIPTION
./bin/silliness/blow_up:3:# TODO: take piped in input?
./bin/templates/firstlife-focus.routine.TEMPLATE:3:# This script (TODO...)
./bin/templates/firstlife-morning.routine.TEMPLATE:16:# TODO: figure out how to keep this stuff on a schedule:
./bin/templates/firstlife-morning.routine.TEMPLATE:38:# - TODO?:: wait until a certain time, 5 minutes after start
./bin/templates/firstlife-morning.routine.TEMPLATE:44:firstlife-delegate --with-reward 'Put on exercise clothes (and make sure you have your housekey/earbuds, etc.) ' || accumulate_error 'not ready exercise' # TODO: --with-timer $(( 2 * 60 ))
./bin/templates/firstlife-morning.routine.TEMPLATE:50:# TODO: listen to podcasts
./bin/templates/firstlife-morning.routine.TEMPLATE:53:firstlife-delegate --with-reward 'finish morning habits' || accumulate_error 'did not finish morning habits' # TODO: list them out individually instead
./bin/templates/firstlife-morning.routine.TEMPLATE:86:# TODO: do I want this here? do I want it in other high-level firstlife scripts?:
./bin/templates/firstlife-multitask.routine.TEMPLATE:23:    || accumulate_error 'should have charged your devices' # TODO: don't ask more than once every 3 hours
./bin/templates/firstlife-multitask.routine.TEMPLATE:42:firstlife-break # TODO: -t 120 # seconds
./bin/templates/firstlife-multitask.routine.TEMPLATE:46:for num in $(seq $PASSES_AT_TODO_LIST); do
./bin/templates/firstlife-multitask.routine.TEMPLATE:120:    today_todo -n | grep '\(CONFIRMING\|--------\|^$\)' # TODO: TEST
./bin/templates/firstlife-multitask.routine.TEMPLATE:121:    firstlife-delegate --with-reward 'Mark something DONE that is "CONFIRMING" in today_todo (if you can)' || accumulate_error 'Did not confirm anything' # TODO: TEST
./bin/templates/firstlife-work.routine.TEMPLATE:3:# This script (TODO...)
./bin/templates/firstlife-work.routine.TEMPLATE:9:    today_todo -n | grep 'DO'NE # TODO: function extract
./bin/templates/firstlife-work.routine.TEMPLATE:21:    firstlife-multitask || accumulate_error 'multitasking ERRORS' # TODO: at least once, maybe longer if there is time
./bin/tmux_dashboard_experimental:3:# This script (...TODO, describe your script here)
./bin/tmux_dashboard_experimental:7:exit_with_error "TODO: IMPLEMENT"
./bin/tmux_dashboard_experimental:8:# TODO: open a tmux with predefined windows with specific sizes, running specific review commands
./bin/today_todo:11:# TODO: flag to grep for and count a specific word, sort of like what I do for "NOW"
./bin/today_todo:12:# TODO: "-q" or "-n" flag to be quick, and skip the editor phase
./bin/today_todo:13:# TODO: how about a mode for the edit phase only?
./bin/today_todo:15:# TODO: this program needs to display some instructions so the user knows how to use it.
./bin/today_todo:16:# TODO: maybe during business hours, show results with "BUSINESS_HOURS" more prominently, and hide them otherwise
./bin/today_todo:29:# TODO: report on tags and their frequency?
./bin/today_todo:38:# TODO: take an option to pass all displayed output through 'grep --color=always <KEYWORD>' so you can just see for example, errands.
./bin/today_todo:62:    # TODO: accept a keyword argument, e.g. "-k WOODSHOP".  When you open the editor it's already searching for it and
./bin/today_todo:87:            $todo_program --non-interactive --color never --exclude-dir log > "${TODAY_todo_DIR}/TODO.$(basename $dir).todo_report.txt"
./bin/today_todo:106:    # TODO: maybe automate the archiving, too?
./bin/today_todo:115:    PAUSE_TO_READ=0 # TODO: set to 10 if passed '--slow' or '-s'
./bin/today_todo:134:    echo "$todo_output" | tail -n 10 | grep --color=always TODO
./bin/today_todo:175:        # TODO: show BUSINESS_HOURS stuff during business hours
./bin/today_todo:176:        # TODO: maybe a cronjob to remind me to do that stuff on my lunch hour
./bin/todo_v0.1:3:# TODO: probably should get rid of this old todo version, but it's pretty funny
./bin/todo_v0.4:26:# TODO: consider supporting an alternate format for votes, something that rubocop won't complain
./bin/todo_v0.4:34:#  TODO: once we have a --delete option, you could write a script that goes through your todo's in
./bin/todo_v0.4:38:# TODO: It would be interesting to have a way to show a histogram of todos by votes.
./bin/todo_v0.4:40:# TODO: maybe todo should suggest -f option when you are using -w mode with manual confirmation for
./bin/todo_v0.4:48:    # TODO: use argparse built-in way of setting defaaults instead:
./bin/todo_v0.4:55:    # TODO: consider different single-letter extension, since -i is often used to mean
./bin/todo_v0.4:57:    # TODO: add_argument('-i', '--ignore-keyword', help = 'TODO')
./bin/todo_v0.4:62:    # TODO: maybe todo should suggest running todo -w when it notices simplifications it could be
./bin/todo_v0.4:65:    arg_parser.add_argument('-n', '--non-interactive', action='store_true', help = 'TODO')
./bin/todo_v0.4:66:    arg_parser.add_argument('-w', '--write', action='store_true', help = 'TODO')
./bin/todo_v0.4:67:    arg_parser.add_argument('-f', '--force', action='store_true', help = 'TODO')
./bin/todo_v0.4:68:    arg_parser.add_argument('-d', '--debug', action='store_true', help = 'TODO')
./bin/todo_v0.4:69:    arg_parser.add_argument('-q', '--quiet', action='store_true', help = 'TODO')
./bin/todo_v0.4:70:    # TODO: have a way to also show a graph that helps you understand how many votes you have across
./bin/todo_v0.4:73:    arg_parser.add_argument('--color', action='store', choices=['never', 'auto', 'always'],  help = 'TODO')
./bin/todo_v0.4:88:    # TODO: clean up exclude dirs so you can pass './todo_report/' and it still means 'todo_report'
./bin/todo_v0.4:93:    # TODO: use argparse built-in way of setting defaaults instead:
./bin/todo_v0.4:95:    # TODO: validate that the keywords can only be letters, underscores, and some basic stuff
./bin/todo_v0.4:111:    global interactive # TODO: eliminate globals
./bin/todo_v0.4:119:    # TODO: refactor, too much nesting:
./bin/todo_v0.4:134:    # TODO: method extract:
./bin/todo_v0.4:160:            def highlight_todo_entry(matchobj): # TODO: can I move this method?:
./bin/todo_v0.4:187:        # TODO: if you want, you could tie this into python's logging framework and do it that way
./bin/todo_v0.4:222:    #   TODO: make sure it works with files of different encodings
./bin/todo_v0.4:237:# TODO: flags:
./bin/todo_v0.4:246:  # TODO: add a command line option to specify a minimum number of votes, so if you pass
./bin/todo_v0.4:250:# TODO: consider spinning this project off, with a not-so-clever name like "tood" or something
./bin/update-skiggety-utils:8:# TODO: set interactivity (to be picked up by other installer scripts) according to whether this is a tty?
./bin/vimwhich:13:# TODO: debug DEFAULT_SCRIPT_LOCATION, I think it's not working
./bin/vimwhich:15:# TODO: DEFAULT_SCRIPT_TEMPLATE=${DEFAULT_SCRIPT_TEMPLATE:-"$SKIGGETY_UTILS_DIR/lib/templates/blank.rb"}
./demo_in_docker:19:# TODO: also, use a lock file to ensure you're not accidentally running multiple instances of this
./demo_in_docker:52:# TODO: maybe run it in the background and then tell you how to connect more to it, then connect, then clean up:
./demo_in_docker:61:# TODO: run a shell with a helpful intro message in the docker container
./demo_in_docker:63:# TODO: after you implement this, figure out what the shortest one liner is to both checkout skiggety utils and run this script.
./installers/basic_prerequisites:31:            "h") exit_with_error "TODO: print usage" ;;
./installers/basic_prerequisites:32:            "?") exit_with_error "TODO: print usage" ;;
./installers/basic_prerequisites:39:    self_hash="$(git hash-object $0)" # TODO: perhaps use a hash that takes the Gemfile into account as well?
./installers/basic_prerequisites:43:    #if ! $interactive; then # TODO: should this really depend on interactive mode? how about unless --force ?
./installers/basic_prerequisites:46:        if find $completed_marker -mtime -1 | grep $completed_marker >/dev/null; then # TODO: explanatory comment
./installers/basic_prerequisites:49:            # TODO: maybe exiting early should also be conditional on whether .tools-versions and maybe other files have
./installers/basic_prerequisites:132:# TODO: pare down the list for asdf (in Dockerfile too), as this list was really created as prerequisites for rbenv and
./installers/basic_prerequisites:197:    echo "Installing nose2" # TODO: move
./installers/crontab:6:# TODO: help configure a ~/.crontab with shellask
./installers/crontab:7:# TODO: run crontab ~/.crontab to make cron aware of the changes
./installers/devkit:7:# TODO: make sure there is a way to run this inside demo_in_docker and then to be able to run 'todo'
./installers/devkit:29:    # TODO: call_peer_installer('shellcheck') if I start using it
./installers/docker:15:    # TODO true if we're in a docker container, same with config
./installers/docker:16:    elsif ask_user 'Is Docker installed (TODO: IMPLEMENT for real)?'
./installers/docker:19:    # TODO: Maybe ruby can sometimes ask_user an ordinary question, and sometimes use shellask:
./installers/evernote:14:      # TODO: Checking the version would be a better approach if possible, I guess:
./installers/evernote:17:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/fzf:31:      raise 'TODO: IMPLEMENT'
./installers/gimp:34:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/git:23:            "h") exit_with_error "TODO: print usage" ;;
./installers/git:24:            "?") exit_with_error "TODO: print usage" ;;
./installers/git:29:    # TODO?: echo "Installing $(basename $0)"
./installers/git:39:    # TODO: install gitk? (brew install git-gui) on mac
./installers/git:50:    # TODO: on linux global config credential.helper cache
./installers/git:56:    # TODO: local reason="$3"
./installers/hostname:8:  # TODO: enforce all-lowercase, numbers not in first character, etc. ...or whatever works for dns
./installers/hostname:10:  # TODO: perhaps require dns server config (check with nslookup or an
./installers/hostname:13:  #   TODO: To systematize this, you could find the ip address of the local gatteway and pop it up in a browser
./installers/hostname:26:    # TODO: verify nslookup, which means router config will be part of configuration process
./installers/hostname:40:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/iterm:16:      raise 'TODO: IMPLEMENT'
./installers/iterm:21:    true # TODO: implement saving profiles if you can
./installers/iterm:26:      brew_install_cask_latest 'iterm2' # TODO: TEST
./installers/iterm:28:      raise 'TODO: IMPLEMENT'
./installers/local-backup:12:      program_version_option_output_matches?('tmutil', / 4\.0\.0 /) # TODO: update desired version
./installers/local-backup:16:      true # TODO: IMPLEMENT
./installers/local-backup:18:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/local-backup:28:      true # TODO: IMPLEMENT
./installers/local-backup:30:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/local-backup:43:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/local-backup:57:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/pstree:30:      raise 'TODO: IMPLEMENT'
./installers/rectangle:19:      true # rectangle not available for other OS'es, I think # TODO: but maybe install some equivalent
./installers/rectangle:42:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/review:11:    false # just play it safe and make sure # TODO: fix this?
./installers/review:21:    mark_installed! # TODO: DELETE once we implement apparently_installed? for real
./installers/ripgrep:32:      raise 'TODO: IMPLEMENT'
./installers/skiggety.bash:29:            "h") exit_with_error "TODO: print usage" ;;
./installers/skiggety.bash:30:            "?") exit_with_error "TODO: print usage" ;;
./installers/synergy:16:      # TODO: Checking the version would be a better approach if possible, I guess:
./installers/synergy:21:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/synergy:49:        raise 'TODO: IMPLEMENT'
./installers/synergy:51:        raise NotImplementedError, 'TODO: implement this for this OS'
./installers/tac:22:      raise 'TODO: implement'
./installers/terminal_profiles:22:      # TODO: ask user less stuff, but we still need a way to return true here when it's been done:
./installers/terminal_profiles:24:      # TODO: commit/sync/install linux terminal profiles?
./installers/terminal_profiles:31:        # TODO: deal with the extra clutter of profiles like "skiggterm 1", "skiggterm 2", etc.  that pile up sometimes.
./installers/tmux:26:      raise 'TODO: IMPLEMENT'
./installers/todo:4:# TODO: can I avoid this whole installer? is there a cleaner way to make sure pip installs get run?
./installers/todo:13:    false # just play it safe and make sure # TODO: fix this?
./installers/todo:24:    mark_installed! # TODO: DELETE once we implement apparently_installed? for real
./installers/uhk_agent:18:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/uhk_agent:25:    # TODO: ask user less stuff, but we still need a way to return true here when it's been done:
./installers/uhk_agent:48:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/vim:8:# TODO: maybe detect local vimrc changes
./installers/vim:15:    # TODO: use File.join or something, not interploation for these:
./installers/vim:20:    # TODO: Dir.exist?("#{bundle_dir}/nerdtree")
./installers/vim:21:    # TODO: Dir.exist?("#{bundle_dir}/vim-dispatch")
./installers/vim:60:    # TODO?: vim-ripgrep & learn to use it (be careful, it seems to have it's own :Rg command that's different from
./installers/vim:63:    # TODO: take a look at tabnine
./installers/vim:65:    # TODO: nerdtree
./installers/vim:66:    # TODO: https://github.com/tpope/vim-dispatch
./installers/vim:85:      # TODO: prompt the user with something to explain what they need to do:
./installers/vim.config/vimrc:48:set rtp+=/usr/local/opt/fzf "TODO: make this cross-platform, this is just where fzf gets installed with brew on mac
./lib/include_in_bashrc.bash:16:export PS1="\$(duh)\$(git branch 2>/dev/null|grep '^*'|sed 's/^\\*/ \\*/') - \D{%F %T}\n\$ " # TODO: add colors (besides duh)
./lib/include_in_bashrc.bash:41:# TODO: use more stuff from older bashrc files I've used
./lib/installable_skiggety_util.rb:5:# TODO: mark more of these methods private
./lib/installable_skiggety_util.rb:7:# TODO: implement uninstall
./lib/installable_skiggety_util.rb:33:    # TODO: also have other files you can watch for changes since last marker file, like this one:
./lib/today_todo.bash:1:TODAY_todo_DIR=${TODAY_todo_DIR:-"$HOME/today_todo"} # TODO: maybe help the user with place to change it in the bashrc template
./lib/todo_line.py:6:# TODO: traditional unit tests for this library
./lib/todo_line.py:16:        def replace_todo_entry(matchobj): # TODO: can I move this method?:
./lib/todo_line.py:17:            # TODO: decide about whether to break out todo_entry as a separate object:
./lib/todo_line.py:22:        #TODO: call "validate" function to filter out bad lines:
./lib/todo_line.py:24:    def __str__(self): # TODO: implement __repr__ too, for use in exceptions
./lib/todo_line.py:45:        # TODO: maybe use a list comprehension instead of map, as it's more pythonic:
./lib/todo_line.py:62:        """TODO: why the heck am I enforcing doc strings on self-explanatory methods like this?"""
./lib/todo_line.py:65:    # TODO: make this more efficient.  Writing a file once per line is silly:
./lib/user_delegation.rb:28:    shellask(question_text) # TODO: real implementation at some point
./start:21:# TODO: I'm not even sure this is a good idea, but maybe reload ~/.bashrc and stuff now that it's been updated by
./start:23:#   . ./lib/reload_env || exit_with_error "could not source \"./lib/reload_env\"" # TODO: don't use relative path
./test/lib/installable_skiggety_util_test.rb:3:# TODO: maybe convert to rspec, make sure install! gets called when it should, etc.
./test/lib/installable_skiggety_util_test.rb:47:  # TODO: test self.run
./test/lib/installable_skiggety_util_test.rb:48:  # TODO: test run
./test/lib/installable_skiggety_util_test.rb:49:  # TODO: test name
./test/lib/installable_skiggety_util_test.rb:50:  # TODO: test mark_installed!
./test/lib/installable_skiggety_util_test.rb:51:  # TODO: test delete_all_config_markers!
./test/lib/installable_skiggety_util_test.rb:52:  # TODO: test mark_configured!
./test/lib/installable_skiggety_util_test.rb:53:  # TODO: test marked_configured?
./test/lib/installable_skiggety_util_test.rb:54:  # TODO: test marked_installed?
./test/lib/installable_skiggety_util_test.rb:55:  # TODO: test delegate_to_user(request_text)
./test/lib/installable_skiggety_util_test.rb:56:  # TODO: test ask_user(request_text)
./test/lib/installable_skiggety_util_test.rb:57:  # TODO: test past_install_marker_file_paths
./test/lib/installable_skiggety_util_test.rb:58:  # TODO: test current_install_marker_file_path
./test/lib/installable_skiggety_util_test.rb:59:  # TODO: test past_config_marker_file_paths
./test/lib/installable_skiggety_util_test.rb:60:  # TODO: test config_marker_file_paths
./test/lib/installable_skiggety_util_test.rb:61:  # TODO: test current_config_marker_file_path
./test/lib/installable_skiggety_util_test.rb:62:  # TODO: test current_install_marker_file_name
./test/lib/installable_skiggety_util_test.rb:63:  # TODO: test install_marker_file_name_prefix
./test/lib/installable_skiggety_util_test.rb:64:  # TODO: test current_config_marker_file_name
./test/lib/installable_skiggety_util_test.rb:65:  # TODO: test config_marker_file_name_prefix
./test/lib/installable_skiggety_util_test.rb:66:  # TODO: test raise_interactive_only_configuration
./test/lib/installable_skiggety_util_test.rb:67:  # TODO: test raise_interactive_only_install
./test/lib/installable_skiggety_util_test.rb:68:  # TODO: test raise_interactive_only_action(action)
./test/lib/installable_skiggety_util_test.rb:69:  # TODO: test config_tree_hash
./test/lib/installable_skiggety_util_test.rb:70:  # TODO: test config_exist?
./test/lib/installable_skiggety_util_test.rb:71:  # TODO: test config_dir_path
./test/lib/installable_skiggety_util_test.rb:72:  # TODO: test self_config_path(file_name)
./test/lib/installable_skiggety_util_test.rb:78:  # TODO: test installer_file_hash (use raw dummy and a stub like with
./test/lib/installable_skiggety_util_test.rb:81:  #   TODO: Perhaps make sure the installer gets read as having run and has no
./test/lib/installable_skiggety_util_test.rb:100:  # TODO: test open_in_browser(url)
./test/lib/installable_skiggety_util_test.rb:102:  # TODO: test on_mac_os? and test on_linux_os? together? maybe make sure
./test/lib/installable_skiggety_util_test.rb:117:  # TODO: test program_version_option_output_matches?(program, version_regex)
./PWD_BIN/ci:14:#    TODO^2: ...so rename this script 'integrate' to get the ball rolling?
./PWD_BIN/ci:18:# TODO^2: what if there are updates to the top-level ci script? should it re-exec itself?
./PWD_BIN/ci:36:# TODO^2: if there are git changes, complain that dev is not read-only
./PWD_BIN/dev:22:# TODO^2: ask Kevin to test if this generation is working for him and if it shows up in his 'todo' output:
./PWD_BIN/install-skiggety-utils:20:    # TODO^2: install custom list app (opens dedicated browser window "as an app") (huh?)
./PWD_BIN/install-skiggety-utils:21:    # TODO^2: install a music player of some sort
./PWD_BIN/lint:29:# TODO^2: abbreviate output:
./PWD_BIN/review-ci:5:# TODO^2: after the RENAME/redesign of 'ci', this script probably will get DELETEd
./PWD_BIN/unit-test:8:# TODO^2: I think I should be using SKIGGETY_UTILS_DIR more widely instead of THIS_DIR:
./PWD_BIN/unit-test:28:# TODO^2: what can I do to make coverage results be trustworthy and meaningful?
./PWD_BIN/unit-test:29:# TODO^2: perhaps ratchet coverage results towards 100%, or make sure it clears a predefined minimum threshold
./README.md:130:  - TODO^2: inforad (chrome extension?) information radiator
./README.md:137:  - TODO^2: once we can abbreviate, maybe choose the linecounts for different things dynamically depending on the terminal size
./README.md:146:- TODO^2: automatically graph gmail progress outstanding messages, by writing a program that takes a url or gmail search string and monitors it. You can check in on the graph periodically to make sure you're on track.
./README.md:150:- TODO^2: collect data on email inbox, etc. and auto-generate graphs for the dashboard
./README.md:152:    - TODO^2: help set up local dns
./README.md:153:  - TODO^2: set up NAS
./README.md:154:- TODO^2: have a way to open the github webpage from inside a git repo from the command line. You can use "open <URL>" on a mac, for example, and scripts like what you use for automatic git pushing can use it to help you get PR's going fast.
./README.md:156:    - TODO^2: hook up to google drive
./README.md:157:- TODO^2: mini-project: raspberry pi backup machine, and the software to run it.
./bin/chbs:27:  # TODO^2: accept and pass through options for min/max words/characters/characters-per-word, plus whether it should
./bin/crontab-verbose:36:        # TODO^2: if the most recent thing to change is this script, we should also run it:
./bin/default_dashboard:13:# TODO^2: only do git stuff if it's a git repository
./bin/duh:11:if [ "$CLICOLOR" == 'xterm-color' ]; then # TODO^2: look at other things that should enable color, CLICOLOR is for mac
./bin/firstlife:43:firstlife-work # TODO^2?: || exit_with_error "firstlife-work FAILED"
./bin/firstlife-evening:8:# TODO^2?: exit if a script with identical name and path is in parent tree
./bin/firstlife-focus:8:# TODO^2?: exit if a script with identical name and path is in parent tree
./bin/firstlife-morning:10:# TODO^2?: exit if a script with identical name and path is in parent tree
./bin/firstlife-multitask:9:# TODO^2?: exit if a script with identical name and path is in parent tree
./bin/firstlife-pomodoro:6:# TODO^2: exit early if you've done enough pomodoros in a day
./bin/firstlife-work:8:# TODO^2?: exit if a script with identical name and path is in parent tree
./bin/git-autobisect:3:# TODO^2: Does the thing that you probably want to do with git bisect without having to remember the subcommands or
./bin/git-log-recent:8:# TODO^2: make this show the timestamp, too:
./bin/git-ready:44:# TODO^2: move/reuse?
./bin/git-ready:49:# TODO^2: move/reuse?
./bin/grim:3:# TODO^2: make this (and others like it) a printable help message:
./bin/grim:60:    vim $VIM_OPTIONS $GRIM_FILES +/"$GRIM_TARGET_STRING$VIM_SEARCH_STRING_SUFFIX" # TODO^2: support readonly vim mode by passing a "-R" flag if this program recieves a "-R"
./bin/review_v0.1:46:# TODO^2: do I need to export LINES and COLUMNS as the output of 'tput lines' and 'tput cols' respectively so the
./bin/review_v0.1:49:# TODO^2: Accept a flag to stop running if the wait gets longer than some specified amount
./bin/review_v0.1:80:    # TODO^2: possibly RENAME "delay" to sleep_interval or wait_time or something and use the terminology consistently.
./bin/review_v0.1:132:      # - TODO^2: Probably oughta have a flag to turn it off too.
./bin/review_v0.1:190:  # TODO^2: probably RENAME these two "fill screen" methods, and maybe DRY the insides of them too:
./bin/review_v0.1:197:      @output = "TODO^2: consider pulling some BS with tee to get output, meanwhile #{rand(99)} should keep it snappy"
./bin/review_v0.1:236:  # TODO^2: this needs to be switchable by command line
./bin/review_v0.1:255:      # TODO^2: show time as hh:mm:ss or something like that:
./bin/review_v0.1:306:  # TODO^2: cleanup timestamp formatting:
./bin/shellask:49:# TODO^2: can we do something to make the terminal tab blink?:
./bin/sleep-verbose:6:# TODO^2?: show a clock, optionally
./bin/sleep-verbose:7:# TODO^2?: integrate into a banner
./bin/templates/firstlife-morning.routine.TEMPLATE:14:# TODO^2: use this to make sure we don't ask for the alarm too often: FIRSTLIFE_ALARM_MARKER_FILE="$FIRSTLIFE_DIR/markers/firstlife_outside_alarm_confirmed"
./bin/templates/firstlife-morning.routine.TEMPLATE:45:firstlife-delegate --with-reward 'Exercise! (Or schedule it for later today)' || accumulate_error 'did not exercise' # TODO^2: --with-timer $(( 30 * 60 ))
./bin/templates/firstlife-multitask.routine.TEMPLATE:144:shellask "Close a couple unecessary terminals, if any" && firstlife-reward || accumulate_error "Did not clean up terminals" # TODO^2: DELETE once firstlife behaves better
./bin/today_todo:127:    # TODO: -n 5 # TODO^2: todo should accept an option for the number of lines.  like "-n 3".  Maybe if we pass an
./bin/today_todo:146:    # TODO^2: if it's around new years:
./bin/todo_v0.4:31:# TODO^2: maybe accept --vote 'substring', --downvote 'substring', or --delete 'substring'  to find
./bin/todo_v0.4:118:    # TODO^2: parallelization might make this a lot faster (learn from rg)
./bin/todo_v0.4:216:    # TODO^2: it is inefficient to re-create these every time, so make them an instance
./bin/todo_v0.4:223:    #   TODO^2: shut up pylint (it wants me to specify an encoding)
./bin/todo_v0.4:240:  # This way you could run "todo bin/todo" and see the TODO^2's in this file cleanly without the
./bin/todo_v0.4:243:  # TODO^2: non-interactive [read-only] mode should be the default when this is called from a script
./bin/vimwhich:10:# TODO^2: consider making this into a generic "editwhich" program, that supports other editors
./demo_in_docker:6:# TODO^2: TEST on windows
./demo_in_docker:53:# TODO^2: can I set the hostname to something friendly so it appears in the prompt?:
./installers/crontab:4:# TODO^2: IMPLEMENT
./installers/git:31:    # TODO^2: maybe install git? at this point we're assuming it's already installed and just going ahead with
./installers/git:42:    # TODO^2: check for marker file to avoid re-running, like in './basic_prerequisites'
./installers/jiggler:10:  raise 'TODO^2: IMPLEMENT'
./installers/local-backup:13:      # TODO^2: how should I keep tabs on new versions of software, in general.  Some automated way to watch for it and
./installers/local-backup:22:  # TODO^2: make sure there was a backup in the last week? (is this the [only] place for this)
./installers/rectangle:26:    # TODO^2: method/module extract?
./installers/skiggety.bash:5:# TODO^2?: reload bashrc after setting it up?
./installers/synergy:6:# TODO^2: The process of downloading and installing Rectangle, Synergy, and
./installers/tmux:39:  # TODO^2: learn tmux better and develop the config.  Here's some stuff to check out:
./installers/vim:7:# TODO^2: install vim rake plugin with vim pathogen
./installers/vim:45:    # TODO^2: install gvim (gui) for linux
./lib/installable_skiggety_util.rb:3:# TODO^2: assert ruby version # puts "DEBUG: in #{name} installer, RUBY_VERSION is \"#{RUBY_VERSION}\"."
./lib/installable_skiggety_util.rb:25:    # TODO^2: should we catch exceptions and print them without a full stack trace?
./lib/installable_skiggety_util.rb:43:        install! # TODO^2: catch exception and wrap in: raise "install! command failed for #{self.class}"
./lib/installable_skiggety_util.rb:104:  # TODO^2: RENAME:
./lib/installable_skiggety_util.rb:178:        # TODO^2: we could return something random so it's different each
./lib/installable_skiggety_util.rb:259:    (version_output =~ version_regex).is_a?(Numeric) # TODO^2: update desired vim version
./lib/skiggety-utils.bash:4:# TODO^2: extract & include shelper.bash which checks bash version, and provides utility functions.
./lib/skiggety-utils.bash:6:# TODO^2: . $THIS_DIR/shelper.bash || exit 1
./lib/user_delegation.rb:31:  # TODO^2: maybe shellask isn't always the best way to ask the user a question.  Change calls to this to call the
./start:26:# TODO: this is something similar that I'm also not sure is a good idea: ./bin/start_in_env.bash || exit_with_error "Could not run \"./bin/start_in_env.bash\"" # TODO: don't use relative path # TODO^2: move most things in here, including any interactive stuff
./test/lib/installable_skiggety_util_test.rb:46:  # TODO^2: test call_peer_installer(name)
./test/test_todo.bash:9:SKIGGETY_DEBUG=true # TODO^2: turn debug output off
./version.txt:2:# TODO^2: enforce version number updating?  This might be needed if we know others are using this code, and there's a
./PWD_BIN/ci:7:# TODO^3: possible script renaming--ci means continuos.  This is just the integration part. "review-ci" could become
./PWD_BIN/generate_todo_report:23:# TODO^3: graph this over time, also maybe total votecount and how many votes the topvoted todo has:
./PWD_BIN/install-skiggety-utils:8:# TODO^3: use a lock file so you don't run this twice at once by accident
./README.md:51:    - TODO^3: fix the BUG where you run todo (PWD_BIN/todo) and then cd to test/ and run todo and it complains
./README.md:129:- TODO^3: toy rails site, need a good idea, maybe it can help with information radiating?
./README.md:136:- TODO^3: write a program to abbreviate output for use in the dashboard. You should be able to specify a maximum number of lines and pipe output through it, and it will do something like "head" or "tail" if necessary, but also display information about how many lines were removed/kept/found-in-total
./README.md:141:- TODO^3: try some editable vim macros
./README.md:149:- TODO^3: maybe skiggety-utils should help set up /Users/skiggety/PWD_BIN/dashboard from a template
./bin/chbs:29:  # TODO^3:  and pass through options for min/max word length (--mwl/--Mwl)
./bin/firstlife:27:    # TODO^3: do something with error count:
./bin/firstlife:48:# EASY TODO^3: every time I do this graph update should be in a routine like morning or evening so it can get skipped:
./bin/firstlife-delegate:32:# TODO^3: accumulate some points?
./bin/git-push-new-branch:2:# TODO^3: RENAME this script
./bin/git-ready:30:    # TODO^3: if the remote branch doesn't exist yet, we should skip trying git pull, since it will fail anyway
./bin/hesitate-and-run:3:# TODO^3: use this more widely, especially in firstlife
./bin/review-today_todo:5:# TODO^3: gotta RENAME this and today_todo.  Underscores in the name are just too weird, especially when mixed with hyphens
./bin/review_v0.1:21:# TODO^3: work on messages in sleep-verbose and the sleep message at the bottom of 'review'
./bin/review_v0.1:222:    # TODO^3: maybe instead of using to_i, convert to decimal with 2-3 places:
./bin/review_v0.1:278:    # TODO^3: get output in interactive mode with tee into a tempfile so interactive mode won't always choose change
./bin/templates/firstlife-focus.routine.TEMPLATE:10:# TODO^3: try to mix in some work pomodoros until there are 16 on a weekday? maybe ask the user how many work pomodoros to do, with a default of 16, and then have you ask for a purpose for each
./bin/today_todo:120:    # TODO^3: consider extracting the rest of this script to "today_todo_display", which can be overridden with PWD_BIN, or
./bin/todo_v0.4:29:# TODO^3: accept piped-in grep output for sorting, like grep does
./bin/todo_v0.4:59:    # TODO^3: how about an argument/mode for the linter that complains about non-compacted todo
./bin/todo_v0.4:165:                # TODO^3: the yellow line should really be everything that's tied for highest votes,
./bin/todo_v0.4:183:# TODO^3: RENAME, remove, move to a new library, or use an existing library?
./bin/vimwhich:7:# TODO^3: accept a "-a" option, and use "which -a" in that case.  This would be useful for "vimwhich
./demo_in_docker:54:# TODO^3: try using docker compose for this:
./installers/basic_prerequisites:71:    # TODO^3: install latest bash and make sure other scripts are compatible...
./installers/hostname:66:# TODO^3: use this more widely if call_peer_installer uses a direct include method?:
./installers/rectangle:41:      # TODO^3: If we install a different program similar to rectangle on a different OS, this script should be RENAMEd.
./installers/vim:6:# TODO^3: install and set up vimpager as your pager, but maybe not in this installer
./installers/vim:75:  # TODO^3: maybe move to installable_skiggety_util.rb:
./installers/vim.config/vimrc:10:" TODO^3: similar auto-load on focus gain?
./lib/installable_skiggety_util.rb:107:    # TODO^3: perhaps if the installer contains 'include InstallableSkiggetyUtil', we should call it in the same process
./lib/installable_skiggety_util.rb:181:        #   TODO^3: maybe just use the latest timestamp, from anywhere in the tree?
./lib/installable_skiggety_util.rb:256:  # TODO^3: RENAME?
./test/lib/installable_skiggety_util_test.rb:38:  # TODO^3: write more tests
./.rubocop_todo.yml:9:# TODO^4: Eliminate this file, bit by bit
./PWD_BIN/install-skiggety-utils:71:    # TODO^4: set up a naming convention for installers, because install-vim might make more sense than vim
./PWD_BIN/lint:30:# TODO^4 automatically scan all python files:
./README.md:55:    - (?) How can I make this safer? (TODO^4: consider direnv: "https://direnv.net/docs/hook.html") and dotenv. Put ./users_safeword/../PWD_BIN" in the path instead? make everything in PWD a subcommand of some other command? Come up with some handy way to add/remove it from the path quickly (or add it temporarily)? I put skiggety-utils/PWD_BIN_FIREWALL in your path before ./PWD_BIN if I wanted to block certain things
./README.md:134:- TODO^4: output license summary in interactive programs (like you're supposed to)??
./README.md:135:- TODO^4: commit initial skigg-utils, to get to parity with what I already like to use
./README.md:138:- TODO^4: consider supporting other shells:
./README.md:139:  - TODO^4: consider supporting zsh
./README.md:142:- TODO^4: set up a git hook system so you can add multiple scripts. For example, I'd like to block commits that include
./README.md:148:- TODO^4: music rotator thingy (Neighbor Shawn might beta test)
./bin/abbreviate:5:# and run tail otherwise.  TODO^4: # Maybe could RENAME it to 'tailmax', 'tail-verbose', or something?
./bin/review_v0.1:86:    start_wake_on_filesystem_change # TODO^4: this should depend on a command line flag
./bin/todo_v0.4:112:    interactive = True # TODO^4: detect if output is to a terminal
./bin/todo_v0.4:146:                        # TODO^4: write more efficiently (all changes from one file at once):
./bin/todo_v0.4:181:    # TODO^4: print summary with TODO count, maybe a vote count
./bin/todo_v0.4:239:  # TODO^4: todo should accept a path ( to a file or directory) to use in place of "." for grep.
./bin/vimwhich:36:    # TODO^4: create $destination file from template if it doesn't exist and mark it executable.
./installers/basic_prerequisites:138:        # TODO^4: un-loop, it's too slow:
./installers/git:34:    #   TODO^4: thinking about this further, asking the user to install the latest git would fit in perfectly with the
./installers/skiggety.bash:35:    # TODO^4: check for marker file to avoid re-running, like in './basic_prerequisites'
./installers/vim:24:  # TODO^4: we need some way of watching other files.  If they are newer than our marker file, we need a reinstall.
./lib/skiggety-utils.bash:166:    echo -ne "\r" # TODO^4: cut this bs out and do it properly, in some places this looks like a newline
./start:29:# help_with_skiggety_utils # TODO^4: RENAME, test/implement something to show the help system if I do more with it.
./PWD_BIN/ci:24:# TODO^5: accumulate error if any local changes are found, i.e. "maybe you want to run 'dev' instead of 'ci'? Do you want
./PWD_BIN/ci:33:# TODO^5: ensure that the mere act of running ci doesn't cause local changes.  I'm looking at PWD_BIN/lint .
./PWD_BIN/dashboard:11:# show diff with old mac files: # TODO^5: work on this diff:
./PWD_BIN/install-skiggety-utils:13:# TODO^5: careful/tentative/untrusting mode, ask user for confirmation as you go.  Might make it easier for others.  It
./PWD_BIN/lint:6:# TODO^5: run shellcheck
./PWD_BIN/lint:31:# TODO^5: get in the habit of keeping everything clean and then use accumulate_error here:
./bin/chbs:12:# TODO^5 Consider making a website that runs this script in the browswer, using https://opalrb.com/
./bin/git-ready:19:    # TODO^5: just exit 0 right here unless there are changes staged
./bin/review_v0.1:40:# TODO^5: Would it be smart to have a cron job that runs 'pkill review' every day at ~7pm on my work laptop? Or should I
./bin/todo_v0.4:4:# TODO^5: break out the next version into it's own project/repo
./demo_in_docker:50:# TODO^5: IMPLEMENT and UNCOMMENT: echo "You can run 'TODO' in another terminal to connect to this container, but the container will stop when this session ends"
./installers/git:41:    # TODO^5: what's with the sporadic syntax error sometime after this?
./lib/installable_skiggety_util.rb:36:        # TODO^5: but what if it is apparently installed, but marked for an old hash (installer has changed), we should
./lib/installable_skiggety_util.rb:146:  # TODO^5: consider changing the naming convention in the installers directory to avoid the
./lib/skiggety-utils.bash:84:# TODO^5: consistent debug/echo function names
./PWD_BIN/install-skiggety-utils:17:# TODO^6: move to bin? I need to make sure I can run it independently of $PWD, though
./PWD_BIN/lint:5:#     TODO^6: '-n' seems good because the command to fix stuff is short, 'lint', and it's short for '--no-changes'
./README.md:128:- TODO^6: some tools for setting up information radiators
./bin/default_dashboard:4:# TODO^6: consider renaming or extracting to git-default-dashboard or git-dashboard considering what this script actually does
./bin/git-attempt-checkout:3:# TODO^6: RENAME this script.  How about "git-findout"?
./bin/git-pretty-pull:3:# TODO^6: maybe RENAME, e.g. 'git-pull-verbose'
./bin/pretty_sleep:30:# TODO^6: DELETE this script once you're sure it's not used
./bin/shellask:47:# TODO^6: can we do something to bring the terminal to the foreground/front?:
./bin/today_todo:10:# TODO^6: RENAME? ("todo-today"?, "todoy")
./bin/today_todo:184:    # TODO^6: add NOW count to this output?:
./README.md:50:    - TODO^7: by the way, figure out how to tack one git repo on to another so you don't have ./PWD_BIN always showing up in the
./README.md:158:# TODO^7: set up bash tab completion ( see: https://apple.stackexchange.com/questions/55875/git-auto-complete-for-branches-at-the-command-line )
./bin/review_v0.1:37:# TODO^7: a control key to wake it up and make it refresh immediately (accept a control character or signal to refresh
./bin/review_v0.1:44:# TODO^7: BUG make sure child processes get killed when you use CTRL + C on this program to stop it
./bin/today_todo:188:        # TODO^7: graph how many are done each day
./bin/templates/firstlife-focus.routine.TEMPLATE:12:today_todo --non-interactive | grep --color=always '\(NOW\|EASY\|--------\|^$\)' # TODO^9: EXTRACT and REUSE this approach that includes the headings
./bin/todo_v0.4:5:#   TODO^9: RENAME this (with Kevin), or at least the next version, to something a bit more unique
./installers/vim:62:    # TODO^9: learn to use nerdcommenter:
./PWD_BIN/lint:4:#   TODO^10: I think the way to handle this is to support a '-w', '--fix', '-n' or '--ro' option
./PWD_BIN/review-ci:8:review -u 600 -m 1800 -M $(( 24 * 60 * 60)) ci # TODO^10: review --ignore-disk (pass a flag for 'review' to ignore filesystem changes, since it is affected by git pull)
./bin/git-attempt-checkout:4:#   TODO^10: maybe set up git tab completion first ( see: https://apple.stackexchange.com/questions/55875/git-auto-complete-for-branches-at-the-command-line )
./PWD_BIN/lint:3:# TODO^11: make this read-only by default, split the write version into another script if necessary
./installers/skiggety.bash.config/bashrc_section.bash:7:# TODO^11: try to at least support nano or vscode:                                                 # FROM_SKIGGETY_UTILS
./bin/templates/firstlife-morning.routine.TEMPLATE:77:# TODO^12: make exit_if_day_is_over aware of errors?
./bin/firstlife-reward:17:# TODO^13: in a shell open a video or play a sound that reminds you about an open shellask to take 1 reward
./bin/todo_v0.4:142:            for line in reversed(lines): # start with the highest-voted ones # TODO^13: optionally, reverse sort all lines
./bin/templates/firstlife-multitask.routine.TEMPLATE:54:    # TODO^14: only do this if you haven't yet cleared them all today yet:
./bin/today_todo:21:# - TODO^16: ..and another mode to vote for everything matching a string
./bin/today_todo:23:#   - TODO^17: .. e.g.: "today_todo --upvote 'truck oil change'"
./bin/today_todo:24:#   - TODO^17: .. e.g.: "today_todo --vote 99 'truck oil change'"
./bin/today_todo:25:#   - TODO^17: .. e.g.: "today_todo --vote +2 'truck oil change'"
./bin/today_todo:26:#   - TODO^17: .. e.g.: "today_todo --vote -1 'laundry'"
./bin/today_todo:27:#   - TODO^17: .. e.g.: "today_todo --upvote-all 'META'"
./bin/today_todo:28:#   - TODO^17: .. e.g.: "today_todo --vote-all +2 'META'"
./bin/today_todo:20:# TODO^19: add a mode to quickly upvote one particular thing, that would call "todo --vote 'substring of my todo line'"
./bin/today_todo:22:# - TODO^19: ..which means todo has to support voting from the command line, and voting for all, and today_todo will pass options through
./bin/todo_v0.4:33:#  TODO^19: in particular '--vote' would be a timesaver, especially if you could use it with today_todo
./bin/firstlife-delegate:22:# TODO^20: in a separate shell we don't wait for, wait a minute and then open a video reminding them they have an open # shellask
./bin/shellask:28:# TODO^20: figure out why this script occasionally fails to set the prompt.  It seems to still get as far as producing a
./README.md:127:  - TODO^21: ...rewrite todo in rust with parallelization (maybe with Kevin), but after [rust koans](https://github.com/crazymykl/rust-koans)
./bin/templates/firstlife-morning.routine.TEMPLATE:8:# TODO^22: this template script should be a laundry list of ideas
./bin/templates/firstlife-morning.routine.TEMPLATE:10:# TODO^22: help user set up crontab like I did (use crontab-verbose?)
./bin/today_todo:9:# TODO^22: have a way to postpone things to a certain date
./installers/basic_prerequisites:105:    # EASY TODO^22: install_rust
./bin/firstlife:20:# - TODO^23 (IN_PROGRESS, NOW): it should set the terminal title
./bin/firstlife-check-email:17:# EASY TODO^24: should firstlife/bin/ be in the path before skiggety_utils so you can override firstlife code?
./bin/firstlife-check-email:19:# EASY TODO^24: inner custom script, at least call it instead if it exists in firstlife/bin..
./bin/today_todo:68:    # EASY TODO^24: graph "CONFIRMING" and Done
./bin/today_todo:69:    # EASY TODO^24: graph total anxiety score, total votecount of all todos
./bin/today_todo:70:    # EASY TODO^25: graph max votecount
./bin/today_todo:19:# - TODO^30?: search for $1 and if it's not found, add one, if it is found, open the file searching for that string
./bin/firstlife:13:# TODO^31: track stats of all kinds
./bin/templates/firstlife-morning.routine.TEMPLATE:12:# TODO^35: with this and other firstlife scripts, make a distinction between the template and a personal one.
./bin/firstlife-wake:16:# TODO^36: alert user with sound, queue videos? mplayer? toaster-ding?
./bin/firstlife-wake:17:# - TODO^36: but first, bring terminal to the front, maybe just as part of firstlife-delegate, too
./bin/firstlife-delegate:24:# - TODO^38: use mplayer in a loop to play something incessantly until you shut it up, optionally
./bin/templates/firstlife-morning.routine.TEMPLATE:28:# - TODO^40: remind yourself what you care about, maybe play a motivational video?
./bin/templates/firstlife-morning.routine.TEMPLATE:18:#   - TODO^41: then make the logs daily, graph the daily linecount
./bin/templates/firstlife-morning.routine.TEMPLATE:17:# - EASY TODO^42: build a timer into firstlife-delegate, keep stats on how long things take, just pairs of task names and times
./bin/firstlife:14:# TODO^43: and firstlife needs a way to keep you on pace, too
./bin/firstlife:45:# EASY TODO^43: (TEST) help with evening routine (maybe only use exit_if_day_is_over in child scripts, or call this from inside # exit_if_day_is_over)
./bin/firstlife-check-email:20:# EASY TODO^44: run only once to completion per day
./README.md:126:  - TODO^46: spin off kid-utils
./bin/firstlife-check-email:21:# EASY TODO^46: use this script widely
./bin/templates/firstlife-work.routine.TEMPLATE:14:# EASY TODO^47: I need different criteria for whether to continue...is it the same day? do you have enough points? Do you want
./bin/firstlife-error:7:exit_with_error "TODO^48: IMPLEMENT: count errors, much like rewards, with a log file, and wrap 'accumulate_error'."
./bin/firstlife-delegate:23:# TODO^50: shellask --alert, inside it try something like ''osascript -e 'display notification "Done!" with title "Long-running shell command" sound name "Hero"' like you saw at 'https://stackoverflow.com/questions/40814932/is-there-a-way-to-bring-terminal-to-front-when-command-is-finished', to bring window to foreground, especially after popping a web page, and do something similar in firstlife-reward if it works:
./bin/firstlife-reward:19:# EASY TODO^50: emit a characteristic "reward" sound, and get all pavlovian about it
./bin/templates/firstlife-multitask.routine.TEMPLATE:20:# EASY TODO^50: use firstlife-reward with description argument(s), generally
./bin/today_todo:149:    # TODO^51: instead of NOW and LATER, tag things with MORNING, EVENING, WEEKEND, BUSINESS_HOURS, etc, and have today_todo watch the clock to know which to highlight
./bin/templates/firstlife-work.routine.TEMPLATE:17:# EASY to get started TODO^53: (IN_PROGRESS) ask about if you have done enough productivity points. Maybe ask how many done today and how many left in the
./bin/templates/firstlife-multitask.routine.TEMPLATE:83:        # EASY TODO^54: loop through known tags:
./README.md:125:  - TODO^55: firstlife
./bin/firstlife-wake:18:# - EASY TODO^58: I think i should play (with mplayer) an annoying sound for a minute, in a 3 minute loop, until I shut it up, called firstlife-alarm
./bin/firstlife:42:# TODO^60: make this program aware of your productivity points, as in, keep going until you have enough:
./bin/firstlife-delegate:26:shellask "$*" || exit_with_error "$0 FAILED to do: $*" # EASY TODO^67: TEST exit_with_error
./bin/templates/firstlife-morning.routine.TEMPLATE:65:# TODO^67: (EASY) check calendar script should be the one to call 'firstlife-reward', at least if you called it with '--with-reward':
./bin/templates/firstlife-morning.routine.TEMPLATE:82:# TODO^67: make sure this only gets asked perhaps once a week:
./bin/templates/firstlife-morning.routine.TEMPLATE:83:shellask 'make sure you have a phone alarm that ensures you log into this laptop in time for your cron job to fire (for tomorrow)' || accumulate_error 'BASIC AUTOMATION PROBLEM: alarm not set' # TODO^67: (EASY) use 'firstlife-delegate' instead
./bin/today_todo:18:# EASY FUN TODO^67: add a mode to quickly add a todo, ideally it would let you specify a votecount too
./bin/templates/firstlife-morning.routine.TEMPLATE:40:# EASY TODO^70: kick off a morning playlist to keep on track for time with the rest of this stuff
./bin/firstlife-pomodoro:5:# EASY TODO^71: use this script more often, maybe against your todo list
./bin/templates/firstlife-multitask.routine.TEMPLATE:26:firstlife-check-calendar || accumulate_error 'did not check calendar' # TODO^71: TEST NOW
./bin/firstlife-pomodoro:16:# EASY TODO^73: successful pomodoros should keep log and count and show score, like rewards and errors. also, count POINTs similarly from lines with 'POINT' in todays todo file.
./bin/firstlife:17:# EASY TODO^83: prompt user to back up ~/firstlife ( $FIRSTLIFE_DIR ) as part of setup/maintenance
./bin/firstlife-alarm:5:# EASY TODO^83: use this more widely
./bin/firstlife-evening:10:exit_if_day_is_over # EASY to chip away at TODO^84: infect this and called scripts with this line all over the place to clean up windows (for ORGANIZATION)
./bin/firstlife-multitask:11:exit_if_day_is_over # EASY to chip away at TODO^84: infect this and called scripts with this line all over the place to clean up windows (for ORGANIZATION)
./bin/firstlife-work:10:exit_if_day_is_over # EASY to chip away at TODO^84: infect this and called scripts with this line all over the place to clean up windows (for ORGANIZATION)
./bin/templates/firstlife-multitask.routine.TEMPLATE:124:    today_todo -n | grep --color=auto '\(NOW\|LATER\|--------\|^$\)' # EASY TODO^84: EXTRACT, and REUSE
./bin/today_todo:103:        vim -o $files_to_open '+/\.\.\.' # TODO^84: here and elsewhere, use $EDITOR, not vim
./demo_in_docker:12:# TODO^84: help the user with mapping a volume for firstlife and today_todo, so he can edit files with any editor, for firstlife's sake
./demo_in_docker:13:# TODO^84: make sure (for firstlife demo'ing) that we can get through enough of the demo_in_docker script with an alternate $EDITOR
./bin/firstlife:12:# TODO^85: ======== Another real demo with Darren using firstlife himself with some decent code readability ============
./bin/templates/firstlife-morning.routine.TEMPLATE:33:# EASY TODO^85: Or better yet, manage the list of videos here and randomize:
./bin/templates/firstlife-multitask.routine.TEMPLATE:47:    # EASY TODO^85: maybe the inside of the loop could be more like merely:
./bin/templates/firstlife-multitask.routine.TEMPLATE:48:    # EASY TODO^85:     today_todo
./bin/templates/firstlife-multitask.routine.TEMPLATE:49:    # EASY TODO^85:     shellask 'work on your one of your top 3 todos and downvote it if appropriate'
./bin/templates/firstlife-multitask.routine.TEMPLATE:84:        # TODO^85: something like this needs to happen actually before you do the task:
./bin/today_todo:169:        if (( $todo_now_count > 4 )); then # EASY TODO^85: UN-HARDCODE
./bin/firstlife:19:# EASY TODO^86: help user start firstlife (including morning routine) with cron like I did, automate ensuring a line in local crontab, and use 'crontab-verbose'?
./bin/firstlife:22:# EASY TODO^86: move elsewhere:
./bin/firstlife:33:# EASY TODO^86: make sure you call firstlife-morning again later, maybe from firstlife-multitask. It should be a no-op if you've done it already, but catch you otherwise.
./bin/firstlife:40:# EASY TODO^86: use 'firstlife-delegate --with-reward' pretty much universally, instead of calling shellask directly
./bin/firstlife-evening:19:# EASY FUN TODO^86: method extract firstlife-exit-if-this-ran-today <task_name> so we can mark other things
./bin/firstlife-evening:26:exit_if_day_is_over # EASY to chip away at TODO^86: infect this and called scripts with this line all over the place to clean up windows (for ORGANIZATION)
./bin/firstlife-evening:34:# EASY FUN TODO^86: method extract firstlife-mark-done <task_name> so we can mark other things:
./bin/firstlife-morning:13:# EASY TODO^86: method extract firstlife-exit-if-this-ran-today <task_name> so we can mark other things
./bin/firstlife-morning:26:# EASY FUN TODO^86: method extract firstlife-mark-done <task_name> so we can mark other things: 'firstlife-mark-done-today $0'
./bin/firstlife-wake:9:# EASY TODO^86: method extract firstlife-exit-if-this-ran-today <task_name> so we can mark other things
./bin/firstlife-wake:27:# EASY FUN TODO^86: method extract firstlife-mark-done <task_name> so we can mark other things: 'firstlife-mark-done-today $0'
./bin/review_v0.1:256:      # EASY TODO^86: make sleep-verbose message look more like this?:
./bin/templates/firstlife-multitask.routine.TEMPLATE:55:    open 'https://www.google.com/calendar/render' # EASY TODO^86: script extract
./bin/templates/firstlife-multitask.routine.TEMPLATE:110:    # TODO^86: if you have not finished all dishes at least once today
./bin/firstlife-evening:13:# EASY TODO^87: normalize scripts with names like:
./bin/templates/firstlife-work.routine.TEMPLATE:27:    exit_if_day_is_over # EASY TODO^87: TEST
./bin/firstlife:11:# TODO^88: ======== First real demo with Darren using firstlife himself ================
./bin/firstlife:24:    # TODO^88: (IN_PROGRESS, EASY) make sure TODO graph exists in an environment variable so you don't commit it:
./bin/firstlife-delegate:5:# EASY TODO^88: use this script widely in firstlife instead of shellask
./bin/firstlife-morning:5:# EASY TODO^88: make sure only firstlife-morning and firstlife-evening limit to running once a day, not other scripts
./bin/templates/firstlife-multitask.routine.TEMPLATE:69:    # EASY TODO^88: extract this bit that works on a few todos to firstlife-work-on-top-n-todos -n $MULTITASKING_CONSTANT
./bin/firstlife:25:    # - TODO^89 (IN_PROGRESS, EASY): if there's no environment variable, suggest the user start a new one and save the link in their bashrc, where the template should be ready.
./bin/templates/firstlife-multitask.routine.TEMPLATE:16:# EASY TODO^89: inside this script and elsewhere, use 'firstlife-delegate --with-reward' instead of calling 'shellask' directly:

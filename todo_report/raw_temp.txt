./bin/silliness/demo_ruby_version_hack:8:# TODO^0: consider adding ruby 3.1.3 back to skiggety utils for this hack to work, or skip it for performance and just
./Dockerfile:15:# TODO: ideally skiggety utils should handle this:
./Dockerfile:55:# TODO: RUN echo "install-skiggety-utils;less README.md;dev" >> /root/.bashrc
./Dockerfile:57:# TODO: set up something helpful to display on the screen when the user logs in with bash
./PWD_BIN/ci:10:#  # TODO: one idea is that 'ci' is something very high level that uses review heavily but probably uses it once to wait
./PWD_BIN/ci:16:# TODO: I think this script should save the output of dev and simply cat it if there is no update from git
./PWD_BIN/ci:29:# TODO: ???: git restore --staged .
./PWD_BIN/ci:38:# SKIGGETY_DEBUG=true # TODO: come up with a format like what I have but with a timestamp and author included, then save
./PWD_BIN/dashboard:28:# TODO?: tell you what command to run to commit changes or whatever
./PWD_BIN/dashboard:29:# TODO?: graph score over time (see program "progress")
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:3:# This script (...TODO, describe your script here)
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:15:while [ $test_num -lt 10 ]; do # TODO: add zeros
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:18:        SKIGGETY_BLINKY_DEBUG=true # TODO: put this right above where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:20:        SKIGGETY_BLINKY_DEBUG=false # TODO: put this right below where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:23:        SKIGGETY_BLINKY_DEBUG=true # TODO: put this right above where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:25:        SKIGGETY_BLINKY_DEBUG=false# TODO: put this right below where you want to draw focus
./PWD_BIN/debug.occasional_shellask_without_prompt.bash:27:        # TODO: LOG ERROR!!!
./PWD_BIN/debug_CFPVOM.bash:8:# TODO: It might be interesting to try running this in different docker containers
./PWD_BIN/debug_CFPVOM.bash:32:    exit_with_error "stopping now: one language at a time TODO: DELETE when the python hack is working everywhere"
./PWD_BIN/dev:6:# TODO: ci has to be able to call this in read-only mode
./PWD_BIN/dev:8:# TODO: in bin/, should there be a dev and a default-dev like with dashboard?
./PWD_BIN/dev:22:# TODO: ask Kevin to test if this generation is working for him and if it shows up in his 'todo' output:
./PWD_BIN/generate_todo_report:3:# TODO: specify to abbreviate in terms of how many todo's to show (3) instead of how many lines to take up on the
./PWD_BIN/generate_todo_report:19:todo_report_body="$(echo "$todo_report_whole" | abbreviate -n $TODO_REPORT_LINES -t 'todo' )"
./PWD_BIN/generate_todo_report:20:todo_report_body_in_color="$(echo "$todo_report_whole_in_color" | abbreviate -n $TODO_REPORT_LINES -t 'todo' )"
./PWD_BIN/generate_todo_report:27:echo "$todo_header" > $TODO_REPORT_FILE
./PWD_BIN/generate_todo_report:28:echo "$todo_header" > $TODO_REPORT_COLOR_FILE
./PWD_BIN/generate_todo_report:29:echo "$todo_report_body" >> $TODO_REPORT_FILE
./PWD_BIN/generate_todo_report:30:echo "$todo_report_body_in_color" >> $TODO_REPORT_COLOR_FILE
./PWD_BIN/generate_todo_report:31:echo "$todo_report_whole" > "$TODO_REPORT_DIR/raw_temp.txt" # TODO: DELETE this line and the resulting file after comparison
./PWD_BIN/generate_todo_report:33:cat $TODO_REPORT_COLOR_FILE
./PWD_BIN/install-skiggety-utils:19:# TODO: install and configure 3rd party programs
./PWD_BIN/install-skiggety-utils:22:    # TODO?: install kubernetes
./PWD_BIN/install-skiggety-utils:23:    # TODO: install/config chrome tab scheduler and/or other stuff to enable a some kind of dashboard in a web browser
./PWD_BIN/install-skiggety-utils:24:    # TODO: install moreutils (http://joeyh.name/code/moreutils/)?
./PWD_BIN/install-skiggety-utils:25:    # TODO: install pocket
./PWD_BIN/install-skiggety-utils:39:    # TODO: add an option to reinstall, meaning delete installers/.markers/*_with_version* first
./PWD_BIN/install-skiggety-utils:40:    #   TODO: have update-skiggety-utils support this option, too
./PWD_BIN/install-skiggety-utils:46:            "h") exit_with_error "TODO: print usage" ;;
./PWD_BIN/install-skiggety-utils:47:            "?") exit_with_error "TODO: print usage" ;;
./PWD_BIN/install-skiggety-utils:57:        # TODO: make sure that when you run "review install-skiggety-utils", this is in non-interactive mode:
./PWD_BIN/lint:5:#     TODO: '-n' seems good because the command to fix stuff is short, 'lint', and it's short for '--no-changes'
./PWD_BIN/lint:28:# TODO: call rupocop with -a OR -P depending on whether this script is in write mode or not (this script should have
./PWD_BIN/review-ci:7:# TODO: consider splitting to default_ and normal version like dashboard and lint
./PWD_BIN/skiggety-skip-installer:1:# TODO: something like: touch installers/.markers/.skip.$1
./PWD_BIN/unit-test:5:# TODO: make output more concise, it takes up a lot of screen space when running 'review-dev' (or 'dev').  Maybe show
./PWD_BIN/unit-test:9:THIS_DIR="$(cd "$(dirname $BASH_SOURCE)";pwd)" # TODO: DELETE?
./PWD_BIN/unit-test:14:# TODO: complain if install-skiggety-utils needs to be run
./PWD_BIN/unit-test:21:# TODO: ./test/test_todo_v0.4.bash || accumulate_error "shell integration tests for 'todo_v0.4' FAILED"
./PWD_BIN/unit-test:22:# TODO: save todo versions with numbers in the names and wrap one of them in todo (a bash script that sets pyenv and
./PWD_BIN/unit-test:46:run_all_python_tests || accumulate_error "Python tests FAILED" # TODO: run ALL python tests"
./README.md:126:  - TODO: "playbot", a program that tunes in youtube livestreams, video meetings, watch later, podcasts and your personal dashboards, automatically. Great as an information radiator.
./README.md:127:  - TODO: something to keep randomized youtube playlists playing without interruption for music and such
./README.md:128:  - TODO: 'rod' would be a good name for a transparent screen locker. It would stand for "Read-Only Display"
./README.md:135:  - TODO: consider trying/supporting fish
./README.md:142:  - TODO: find a tool that can show graphs of provided data on the command line
./README.md:145:  - TODO: set up router
./README.md:149:- TODO: systematized config (automate the configuration I always want anyway)
./README.md:152:- TODO: document usage of commands
./README.md:153:- TODO: help set up home data center?
./README.md:154:- TODO: put a directory in skigg-utils that contains reference/demo code that shows you how to do certain things
./README.md:155:- TODO: implement ratcheting that can be used for code coverage, number of intstances of a string, number of lint failures, etc. It should be usable as part of a pre-merge hook for git and/or blocking a github pull request
./README.md:156:- TODO: is there a way to commit TODO's somewhere other than local, but not show them publicly on github (I have gitignore files available, but a branching convention might be ghood for keeping them in code)?
./README.md:157:- TODO: An [opinionated] tool for automatically seeding/templating new projects
./README.md:158:- TODO: utility for timestamping [log] output like this: https://serverfault.com/questions/310098/how-to-add-a-timestamp-to-bash-script-log
./README.md:159:- TODO?: gol - Short for "Git Off my Lawn", this would be an opinionated command-line front end for git.
./bin/abbreviate:25:    # TODO: help option should explain that -n tells it how many lines of screen space to use, including the explanation
./bin/chbs:21:  # TODO: consider a --dense (a.k.a. --troubador a.k.a. -d) mode to generate secure passwords in the traditional style
./bin/chbs:24:  # TODO: maybe accept a flag that makes this print one and only one passphrase, with no other output.  It could be used
./bin/chbs:32:    # TODO: # consider (optionally? If there's an internet connection) using the
./bin/chbs:33:    # TODO: # EFF word list:
./bin/chbs:34:    # TODO: # https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt
./bin/chbs:101:    4 # TODO: UN-HARDCODE
./bin/chbs:105:    10 # TODO: UN-HARDCODE
./bin/chbs:124:    # TODO: make this optional
./bin/dashboard:5:# TODO: some convenience for copying this to start a new dashboard (for some other project).  Something like:
./bin/default_dashboard:2:# TODO: consider #!/usr/bin/env python3 OR #!/usr/bin/env ruby
./bin/default_dashboard:25:# TODO: why is this producing so much output lately, like in content manager, even when there have only been a few
./bin/default_dashboard:33:# TODO: this shows a more complete diff, including new files...do I want to use it instead?: for next in $( git ls-files --others --exclude-standard ) ; do git --no-pager diff --no-index /dev/null $next; done; # git diff
./bin/duh:7:COLOR1='' # TODO
./bin/duh:8:COLOR2='' # TODO
./bin/duh:9:COLOR3='' # TODO
./bin/git-attempt-merge:3:# TODO: IMPLEMENT: like git-attempt-checkout, but for merge
./bin/git-object-to-added-keyword:17:    # TODO: echoing the line number this is coming from is distracting:
./bin/git-push-new-branch:4:# TODO: capture output and open browser to new pull request automatically
./bin/git-ready:11:        # TODO: -m "commit comment"
./bin/git-ready:27:    # TODO: just exit 0 right here unless there are changes staged (yes, we're checking again because the user might
./bin/grim:32:        echo "TODO: IMPLEMENT more passthrough options for vim or grep?" >&2; exit 1
./bin/grim:43:# TODO: DELETE?
./bin/grim:49:# TODO: rip out old grep?
./bin/grim:54:# TODO: Maybe other arguments passed in can be sent to vim, so you can to gvim or -O
./bin/grim:55:# TODO: what if a regex gets passed in? can you get the same one to work for grep and vim?
./bin/hesitate-and-run:3:# TODO: ask-to-run could be a similar script, using shellask and used by today_todo & ./start
./bin/lint:5:# TODO: split into default_lint and lint like with dashboard
./bin/misc_lint:5:exit_with_error "TODO: IMPLEMENT..."
./bin/misc_lint:6:# TODO: complain if PWD_BIN/dev is too long (use wc)
./bin/newbin:5:# TODO: DRY functionality with vimwhich, there is or at least should be some overlap.  Maybe vimwhich should call newbin
./bin/newbin:32:    # TODO: frozen string literal thingy if ruby
./bin/newbin:35:        # TODO: copy a template file:
./bin/psbranch:18:    # TODO: command line switch to show only what' in your one terminal bypassing $YOUNG_ANCESTOR instead of
./bin/psbranch:83:# TODO: DEBUG why this returns multiple users sometimes (try passing 0)
./bin/review:48:# TODO: BUG watch out for this program pinning the cpu
./bin/review:49:# TODO: accept log file that logs output, changes, frequencies/counts, etc.
./bin/review:50:# TODO: ensure we never mess with the colors, test with "review git diff"
./bin/review:52:# TODO: rubocop says this class is long (see .rubocop_todo.yml), is parse_args the part to extract?:
./bin/review:62:    # TODO: minimum_delay, etc.
./bin/review:77:    @delay = minimum_delay # TODO: we don't have to start with the minimum, we could take a flag
./bin/review:127:      # TODO: --timeout <n>, or in other words kill commands after this many seconds..
./bin/review:128:      # TODO: should be able to specify min/max delay from the command line as hh:mm:ss if you want:
./bin/review:229:    # TODO: think about how it would be nice to set @wake_up_now = false before the command runs to catch filesystem
./bin/review-dev:4:# TODO: consider renaming this to template_review-dev or default something
./bin/scratch:5:# TODO: move to 'kid-utils'?
./bin/shellask:28:#     TODO: figure out roughly what % of the time it happens, maybe with a test harness that repeats and logs 1000 times
./bin/silliness/blow_up:3:# TODO: take piped in input?
./bin/silliness/demo_python_version_hack:17:# TODO: THIS SHOULD NOT BE NECESSARY! WHY? OH, WHY?!?! (maybe learn more about pyenv and how python
./bin/silliness/demo_python_version_hack:64:    # TODO: probably should only do this if pyenv shims are in the path somewhere
./bin/silliness/demo_ruby_version_hack:30:  # TODO: IMPLEMENT'
./bin/silliness/review-live:3:# TODO: schedule this program in a terminal in the morning
./bin/today_todo:7:# TODO: flag to grep for and count a specific word, sort of like what I do for "NOW"
./bin/today_todo:8:# TODO: "-q" or "-n" flag to be quick, and skip the editor phase
./bin/today_todo:9:# TODO: how about a mode for the edit phase only?
./bin/today_todo:11:# TODO: this program needs to display some instructions so the user knows how to use it.
./bin/today_todo:12:# TODO: maybe during business hours, show results with "BUSINESS_HOURS" more prominently, and hide them otherwise
./bin/today_todo:46:    # TODO: accept a keyword argument, e.g. "-k WOODSHOP".  When you open the editor it's already searching for it and
./bin/today_todo:67:    # TODO: maybe automate the archiving, too?
./bin/today_todo:77:    # TODO: consider extracting the rest of this script to "today_todo_display", which can be overridden with PWD_BIN, or
./bin/today_todo:91:    echo "$todo_output" | tail -n 10 | grep --color=always TODO
./bin/today_todo:133:        # TODO: show BUSINESS_HOURS stuff during business hours
./bin/today_todo:134:        # TODO: maybe a cronjob to remind me to do that stuff on my lunch hour
./bin/today_todo:148:        # TODO: what date format should I use?:
./bin/todo_v0.1:3:# TODO: probably should get rid of this old todo version, but it's pretty funny
./bin/todo_v0.4:26:# TODO: consider supporting an alternate format for votes, something that rubocop won't complain
./bin/todo_v0.4:34:#  TODO: once we have a --delete option, you could write a script that goes through your todo's in
./bin/todo_v0.4:38:# TODO: It would be interesting to have a way to show a histogram of todos by votes.
./bin/todo_v0.4:40:# TODO: maybe todo should suggest -f option when you are using -w mode with manual confirmation for
./bin/todo_v0.4:48:    # TODO: use argparse built-in way of setting defaaults instead:
./bin/todo_v0.4:55:    # TODO: consider different single-letter extension, since -i is often used to mean
./bin/todo_v0.4:57:    # TODO: add_argument('-i', '--ignore-keyword', help = 'TODO')
./bin/todo_v0.4:62:    # TODO: maybe todo should suggest running todo -w when it notices simplifications it could be
./bin/todo_v0.4:65:    # TODO: what's the one-character version of the '--non-interactive' flag?:
./bin/todo_v0.4:66:    arg_parser.add_argument('--non-interactive', action='store_true', help = 'TODO')
./bin/todo_v0.4:67:    arg_parser.add_argument('-w', '--write', action='store_true', help = 'TODO')
./bin/todo_v0.4:68:    arg_parser.add_argument('-f', '--force', action='store_true', help = 'TODO')
./bin/todo_v0.4:69:    arg_parser.add_argument('-d', '--debug', action='store_true', help = 'TODO')
./bin/todo_v0.4:70:    arg_parser.add_argument('-q', '--quiet', action='store_true', help = 'TODO')
./bin/todo_v0.4:71:    # TODO: have a way to also show a graph that helps you understand how many votes you have across
./bin/todo_v0.4:74:    arg_parser.add_argument('--color', action='store', choices=['never', 'auto', 'always'],  help = 'TODO')
./bin/todo_v0.4:89:    # TODO: clean up exclude dirs so you can pass './todo_report/' and it still means 'todo_report'
./bin/todo_v0.4:94:    # TODO: use argparse built-in way of setting defaaults instead:
./bin/todo_v0.4:96:    # TODO: validate that the keywords can only be letters, underscores, and some basic stuff
./bin/todo_v0.4:112:    global interactive # TODO: eliminate globals
./bin/todo_v0.4:120:    # TODO: refactor, too much nesting:
./bin/todo_v0.4:135:    # TODO: method extract:
./bin/todo_v0.4:161:            def highlight_todo_entry(matchobj): # TODO: can I move this method?:
./bin/todo_v0.4:188:        # TODO: if you want, you could tie this into python's logging framework and do it that way
./bin/todo_v0.4:223:    #   TODO: make sure it works with files of different encodings
./bin/todo_v0.4:238:# TODO: flags:
./bin/todo_v0.4:247:  # TODO: add a command line option to specify a minimum number of votes, so if you pass
./bin/todo_v0.4:251:# TODO: consider spinning this project off, with a not-so-clever name like "tood" or something
./bin/update-skiggety-utils:8:# TODO: set interactivity (to be picked up by other installer scripts) according to whether this is a tty?
./bin/vimwhich:13:# TODO: debug DEFAULT_SCRIPT_LOCATION, I think it's not working
./bin/vimwhich:15:# TODO: DEFAULT_SCRIPT_TEMPLATE=${DEFAULT_SCRIPT_TEMPLATE:-"$SKIGGETY_UTILS_DIR/lib/templates/blank.rb"}
./demo_in_docker:16:# TODO: also, use a lock file to ensure you're not accidentally running multiple instances of this
./demo_in_docker:50:# TODO: maybe run it in the background and then tell you how to connect more to it, then connect, then clean up:
./demo_in_docker:59:# TODO: run a shell with a helpful intro message in the docker container
./demo_in_docker:61:# TODO: after you implement this, figure out what the shortest one liner is to checkout skiggety utils, and run this
./installers/basic_prerequisites:32:            "h") exit_with_error "TODO: print usage" ;;
./installers/basic_prerequisites:33:            "?") exit_with_error "TODO: print usage" ;;
./installers/basic_prerequisites:40:    self_hash="$(git hash-object $0)" # TODO: perhaps use a hash that takes the Gemfile into account as well?
./installers/basic_prerequisites:44:    #if ! $interactive; then # TODO: should this really depend on interactive mode? how about unless --force ?
./installers/basic_prerequisites:47:        if find $completed_marker -mtime -1 | grep $completed_marker >/dev/null; then # TODO: explanatory comment
./installers/basic_prerequisites:50:            # TODO: maybe exiting early should also be conditional on whether .python-version has been updated since the
./installers/basic_prerequisites:109:    else # TODO: if on linux
./installers/basic_prerequisites:141:    # TODO: could do something fancy involving grep -R DESIRED_RUBY_VERSION to avoid hardcoding version numbers here,
./installers/basic_prerequisites:144:    ruby_versions="$main_ruby_version" # TODO: add " 3.1.3" when you need it for demo_ruby_version_hack
./installers/basic_prerequisites:204:    echo "Installing nose2" # TODO: move
./installers/crontab:4:# TODO: help configure a ~/.crontab with shellask
./installers/crontab:5:# TODO: run crontab ~/.crontab to make cron aware of the changes
./installers/devkit:5:# TODO: make sure there is a way to run this inside demo_in_docker and then to be able to run 'todo' or at least
./installers/devkit:27:    # TODO: call_peer_installer('shellcheck') if I start using it
./installers/docker:15:    # TODO true if we're in a docker container, same with config
./installers/docker:16:    elsif ask_user 'Is Docker installed (TODO: IMPLEMENT for real)?'
./installers/docker:19:    # TODO: Maybe ruby can sometimes ask_user an ordinary question, and sometimes use shellask:
./installers/evernote:14:      # TODO: Checking the version would be a better approach if possible, I guess:
./installers/evernote:17:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/fzf:31:      raise 'TODO: IMPLEMENT'
./installers/gimp:34:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/git:23:            "h") exit_with_error "TODO: print usage" ;;
./installers/git:24:            "?") exit_with_error "TODO: print usage" ;;
./installers/git:29:    # TODO?: echo "Installing $(basename $0)"
./installers/git:39:    # TODO: install gitk? (brew install git-gui) on mac
./installers/git:50:    # TODO: on linux global config credential.helper cache
./installers/git:56:    # TODO: local reason="$3"
./installers/hostname:8:  # TODO: enforce all-lowercase, numbers not in first character, etc. ...or whatever works for dns
./installers/hostname:10:  # TODO: perhaps require dns server config (check with nslookup or an
./installers/hostname:13:  #   TODO: To systematize this, you could find the ip address of the local gatteway and pop it up in a browser
./installers/hostname:26:    # TODO: verify nslookup, which means router config will be part of configuration process
./installers/hostname:40:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/iterm:16:      raise 'TODO: IMPLEMENT'
./installers/iterm:21:    true # TODO: implement saving profiles if you can
./installers/iterm:26:      brew_install_cask_latest 'iterm2' # TODO: TEST
./installers/iterm:28:      raise 'TODO: IMPLEMENT'
./installers/local-backup:12:      program_version_option_output_matches?('tmutil', / 4\.0\.0 /) # TODO: update desired version
./installers/local-backup:16:      true # TODO: IMPLEMENT
./installers/local-backup:18:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/local-backup:28:      true # TODO: IMPLEMENT
./installers/local-backup:30:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/local-backup:43:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/local-backup:57:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/pstree:30:      raise 'TODO: IMPLEMENT'
./installers/rectangle:19:      true # rectangle not available for other OS'es, I think # TODO: but maybe install some equivalent
./installers/rectangle:42:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/review:11:    false # just play it safe and make sure # TODO: fix this?
./installers/review:21:    mark_installed! # TODO: DELETE once we implement apparently_installed? for real
./installers/ripgrep:32:      raise 'TODO: IMPLEMENT'
./installers/skiggety.bash:29:            "h") exit_with_error "TODO: print usage" ;;
./installers/skiggety.bash:30:            "?") exit_with_error "TODO: print usage" ;;
./installers/synergy:16:      # TODO: Checking the version would be a better approach if possible, I guess:
./installers/synergy:21:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/synergy:49:        raise 'TODO: IMPLEMENT'
./installers/synergy:51:        raise NotImplementedError, 'TODO: implement this for this OS'
./installers/tac:22:      raise 'TODO: implement'
./installers/terminal_profiles:22:      # TODO: ask user less stuff, but we still need a way to return true here when it's been done:
./installers/terminal_profiles:24:      # TODO: commit/sync/install linux terminal profiles?
./installers/terminal_profiles:31:        # TODO: deal with the extra clutter of profiles like "skiggterm 1", "skiggterm 2", etc.  that pile up sometimes.
./installers/tmux:26:      raise 'TODO: IMPLEMENT'
./installers/todo:4:# TODO: can I avoid this whole installer? is there a cleaner way to make sure pip installs get run?
./installers/todo:13:    false # just play it safe and make sure # TODO: fix this?
./installers/todo:24:    mark_installed! # TODO: DELETE once we implement apparently_installed? for real
./installers/uhk_agent:18:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/uhk_agent:25:    # TODO: ask user less stuff, but we still need a way to return true here when it's been done:
./installers/uhk_agent:48:      raise NotImplementedError, 'TODO: implement this for this OS'
./installers/vim:8:# TODO: maybe detect local vimrc changes
./installers/vim:15:    # TODO: use File.join or something, not interploation for these:
./installers/vim:20:    # TODO: Dir.exist?("#{bundle_dir}/nerdtree")
./installers/vim:21:    # TODO: Dir.exist?("#{bundle_dir}/vim-dispatch")
./installers/vim:60:    # TODO?: vim-ripgrep & learn to use it (be careful, it seems to have it's own :Rg command that's different from
./installers/vim:64:    # TODO: nerdtree
./installers/vim:65:    # TODO: https://github.com/tpope/vim-dispatch
./installers/vim:84:      # TODO: prompt the user with something to explain what they need to do:
./installers/vim.config/vimrc:46:set rtp+=/usr/local/opt/fzf "TODO: make this cross-platform, this is just where fzf gets installed with brew on mac
./lib/include_in_bashrc.bash:5:# TODO: somebody please set this to nano and then submit a pr to make other stuff work with nano, lol
./lib/include_in_bashrc.bash:14:export PS1="\$(duh)\$(git branch 2>/dev/null|grep '^*'|sed 's/^\\*/ \\*/') - \D{%F %T}\n\$ " # TODO: add colors (besides duh)
./lib/include_in_bashrc.bash:34:# TODO: use more stuff from older bashrc files I've used
./lib/installable_skiggety_util.rb:5:# TODO: mark more of these methods private
./lib/installable_skiggety_util.rb:7:# TODO: implement uninstall
./lib/installable_skiggety_util.rb:33:    # TODO: also have other files you can watch for changes since last marker file, like this one:
./lib/todo_line.py:6:# TODO: traditional unit tests for this library
./lib/todo_line.py:16:        def replace_todo_entry(matchobj): # TODO: can I move this method?:
./lib/todo_line.py:17:            # TODO: decide about whether to break out todo_entry as a separate object:
./lib/todo_line.py:22:        #TODO: call "validate" function to filter out bad lines:
./lib/todo_line.py:24:    def __str__(self): # TODO: implement __repr__ too, for use in exceptions
./lib/todo_line.py:45:        # TODO: maybe use a list comprehension instead of map, as it's more pythonic:
./lib/todo_line.py:62:        """TODO: why the heck am I enforcing doc strings on self-explanatory methods like this?"""
./lib/todo_line.py:65:    # TODO: make this more efficient.  Writing a file once per line is silly:
./lib/user_delegation.rb:28:    shellask(question_text) # TODO: real implementation at some point
./start:21:# TODO: I'm not even sure this is a good idea, but maybe reload ~/.bashrc and stuff now that it's been updated by
./start:23:#   . ./lib/reload_env || exit_with_error "could not source \"./lib/reload_env\"" # TODO: don't use relative path
./test/lib/installable_skiggety_util_test.rb:3:# TODO: maybe convert to rspec, make sure install! gets called when it should, etc.
./test/lib/installable_skiggety_util_test.rb:47:  # TODO: test self.run
./test/lib/installable_skiggety_util_test.rb:48:  # TODO: test run
./test/lib/installable_skiggety_util_test.rb:49:  # TODO: test name
./test/lib/installable_skiggety_util_test.rb:50:  # TODO: test mark_installed!
./test/lib/installable_skiggety_util_test.rb:51:  # TODO: test delete_all_config_markers!
./test/lib/installable_skiggety_util_test.rb:52:  # TODO: test mark_configured!
./test/lib/installable_skiggety_util_test.rb:53:  # TODO: test marked_configured?
./test/lib/installable_skiggety_util_test.rb:54:  # TODO: test marked_installed?
./test/lib/installable_skiggety_util_test.rb:55:  # TODO: test delegate_to_user(request_text)
./test/lib/installable_skiggety_util_test.rb:56:  # TODO: test ask_user(request_text)
./test/lib/installable_skiggety_util_test.rb:57:  # TODO: test past_install_marker_file_paths
./test/lib/installable_skiggety_util_test.rb:58:  # TODO: test current_install_marker_file_path
./test/lib/installable_skiggety_util_test.rb:59:  # TODO: test past_config_marker_file_paths
./test/lib/installable_skiggety_util_test.rb:60:  # TODO: test config_marker_file_paths
./test/lib/installable_skiggety_util_test.rb:61:  # TODO: test current_config_marker_file_path
./test/lib/installable_skiggety_util_test.rb:62:  # TODO: test current_install_marker_file_name
./test/lib/installable_skiggety_util_test.rb:63:  # TODO: test install_marker_file_name_prefix
./test/lib/installable_skiggety_util_test.rb:64:  # TODO: test current_config_marker_file_name
./test/lib/installable_skiggety_util_test.rb:65:  # TODO: test config_marker_file_name_prefix
./test/lib/installable_skiggety_util_test.rb:66:  # TODO: test raise_interactive_only_configuration
./test/lib/installable_skiggety_util_test.rb:67:  # TODO: test raise_interactive_only_install
./test/lib/installable_skiggety_util_test.rb:68:  # TODO: test raise_interactive_only_action(action)
./test/lib/installable_skiggety_util_test.rb:69:  # TODO: test config_tree_hash
./test/lib/installable_skiggety_util_test.rb:70:  # TODO: test config_exist?
./test/lib/installable_skiggety_util_test.rb:71:  # TODO: test config_dir_path
./test/lib/installable_skiggety_util_test.rb:72:  # TODO: test self_config_path(file_name)
./test/lib/installable_skiggety_util_test.rb:78:  # TODO: test installer_file_hash (use raw dummy and a stub like with
./test/lib/installable_skiggety_util_test.rb:81:  #   TODO: Perhaps make sure the installer gets read as having run and has no
./test/lib/installable_skiggety_util_test.rb:100:  # TODO: test open_in_browser(url)
./test/lib/installable_skiggety_util_test.rb:102:  # TODO: test on_mac_os? and test on_linux_os? together? maybe make sure
./test/lib/installable_skiggety_util_test.rb:117:  # TODO: test program_version_option_output_matches?(program, version_regex)
./PWD_BIN/ci:14:#    TODO^2: ...so rename this script 'integrate' to get the ball rolling?
./PWD_BIN/ci:18:# TODO^2: what if there are updates to the top-level ci script? should it re-exec itself?
./PWD_BIN/ci:34:# TODO^2: if there are git changes, complain that dev is not read-only
./PWD_BIN/debug_CFPVOM.bash:36:# TODO^2: DELETE this script when done
./PWD_BIN/install-skiggety-utils:20:    # TODO^2: install custom list app (opens dedicated browser window "as an app") (huh?)
./PWD_BIN/install-skiggety-utils:21:    # TODO^2: install a music player of some sort
./PWD_BIN/lint:22:# TODO^2: abbreviate output:
./PWD_BIN/review-ci:5:# TODO^2: after the RENAME/redesign of 'ci', this script probably will get DELETEd
./PWD_BIN/unit-test:8:# TODO^2: I think I should be using SKIGGETY_UTILS_DIR more widely instead of THIS_DIR:
./PWD_BIN/unit-test:30:# TODO^2: what can I do to make coverage results be trustworthy and meaningful?
./PWD_BIN/unit-test:31:# TODO^2: perhaps ratchet coverage results towards 100%, or make sure it clears a predefined minimum threshold
./README.md:125:  - TODO^2: inforad (chrome extension?) information radiator
./README.md:132:  - TODO^2: once we can abbreviate, maybe choose the linecounts for different things dynamically depending on the terminal size
./README.md:141:- TODO^2: automatically graph gmail progress outstanding messages, by writing a program that takes a url or gmail search string and monitors it. You can check in on the graph periodically to make sure you're on track.
./README.md:144:- TODO^2: collect data on email inbox, etc. and auto-generate graphs for the dashboard
./README.md:146:    - TODO^2: help set up local dns
./README.md:147:  - TODO^2: set up NAS
./README.md:148:- TODO^2: have a way to open the github webpage from inside a git repo from the command line. You can use "open <URL>" on a mac, for example, and scripts like what you use for automatic git pushing can use it to help you get PR's going fast.
./README.md:150:    - TODO^2: hook up to google drive
./README.md:151:- TODO^2: mini-project: raspberry pi backup machine, and the software to run it.
./bin/abbreviate:23:    # TODO^2: an alternate option to specify in terms of how many of the original lines to show instead of how many lines
./bin/chbs:27:  # TODO^2: accept and pass through options for min/max words/characters/characters-per-word, plus whether it should
./bin/crontab-verbose:35:        # TODO^2: if the most recent thing to change is this script, we should also run it:
./bin/default_dashboard:13:# TODO^2: only do git stuff if it's a git repository
./bin/duh:11:if [ "$CLICOLOR" == 'xterm-color' ]; then # TODO^2: look at other things that should enable color, CLICOLOR is for mac
./bin/git-autobisect:3:# TODO^2: Does the thing that you probably want to do with git bisect without having to remember the subcommands or
./bin/git-pretty-pull:9:# TODO^2: make this show the timestamp, too:
./bin/git-ready:44:# TODO^2: move/reuse?
./bin/git-ready:49:# TODO^2: move/reuse?
./bin/grim:3:# TODO^2: make this (and others like it) a printable help message:
./bin/grim:60:    vim $VIM_OPTIONS $GRIM_FILES +/"$GRIM_TARGET_STRING$VIM_SEARCH_STRING_SUFFIX" # TODO^2: support readonly vim mode by passing a "-R" flag if this program recieves a "-R"
./bin/review:44:# TODO^2: do I need to export LINES and COLUMNS as the output of 'tput lines' and 'tput cols' respectively so the
./bin/review:47:# TODO^2: Accept a flag to stop running if the wait gets longer than some specified amount
./bin/review:76:    # TODO^2: possibly RENAME "delay" to sleep_interval or wait_time or something and use the terminology consistently.
./bin/review:173:  # TODO^2: probably RENAME these two "fill screen" methods, and maybe DRY the insides of them too:
./bin/review:180:      @output = "TODO^2: consider pulling some BS with tee to get output, meanwhile #{rand(99)} should keep it snappy"
./bin/review:219:  # TODO^2: this needs to be switchable by command line
./bin/review:242:    # TODO^2: show time as hh:mm:ss or something like that:
./bin/review:285:  # TODO^2: cleanup timestamp formatting:
./bin/review-today_todo:3:# TODO^2: gotta RENAME this and today_todo.  Underscores in the name are just too weird, especially when mixed with hyphens
./bin/shellask:43:# TODO^2: can we do something to make the terminal tab blink?:
./bin/silliness/demo_python_version_hack:61:    # TODO^2: is there something slightly cleaner I could do like run the child in a fresh login shell
./bin/silliness/demo_ruby_version_hack:41:  # TODO^2: is there something slightly cleaner I could do like run the child in a fresh login shell or something to
./bin/sleep-verbose:6:# TODO^2?: show a clock, optionally
./bin/sleep-verbose:7:# TODO^2?: integrate into a banner
./bin/today_todo:84:    # TODO: -n 5 # TODO^2: todo should accept an option for the number of lines.  like "-n 3".  Maybe if we pass an
./bin/today_todo:103:    # TODO^2: if it's around new years:
./bin/today_todo:123:    # TODO^2: NOW output should be highlighted.
./bin/todo_v0.4:31:# TODO^2: maybe accept --vote 'substring', --downvote 'substring', or --delete 'substring'  to find
./bin/todo_v0.4:119:    # TODO^2: parallelization might make this a lot faster (learn from rg)
./bin/todo_v0.4:217:    # TODO^2: it is inefficient to re-create these every time, so make them an instance
./bin/todo_v0.4:224:    #   TODO^2: shut up pylint (it wants me to specify an encoding)
./bin/todo_v0.4:241:  # This way you could run "todo bin/todo" and see the TODO^2's in this file cleanly without the
./bin/todo_v0.4:244:  # TODO^2: non-interactive [read-only] mode should be the default when this is called from a script
./bin/vimwhich:10:# TODO^2: consider making this into a generic "editwhich" program, that supports other editors
./demo_in_docker:6:# TODO^2: TEST on windows
./demo_in_docker:51:# TODO^2: can I set the hostname to something friendly so it appears in the prompt?:
./installers/basic_prerequisites:136:    # TODO^2: install rbenv-aliases?
./installers/git:31:    # TODO^2: maybe install git? at this point we're assuming it's already installed and just going ahead with
./installers/git:42:    # TODO^2: check for marker file to avoid re-running, like in './basic_prerequisites'
./installers/hostname:66:# TODO^2: use this more widely if call_peer_installer uses a direct include method?:
./installers/jiggler:10:  raise 'TODO^2: IMPLEMENT'
./installers/local-backup:13:      # TODO^2: how should I keep tabs on new versions of software, in general.  Some automated way to watch for it and
./installers/local-backup:22:  # TODO^2: make sure there was a backup in the last week? (is this the [only] place for this)
./installers/rectangle:26:    # TODO^2: method/module extract?
./installers/skiggety.bash:5:# TODO^2?: reload bashrc after setting it up?
./installers/synergy:6:# TODO^2: The process of downloading and installing Rectangle, Synergy, and
./installers/tmux:39:  # TODO^2: learn tmux better and develop the config.  Here's some stuff to check out:
./installers/vim:7:# TODO^2: install vim rake plugin with vim pathogen
./installers/vim:45:    # TODO^2: install gvim (gui) for linux
./lib/installable_skiggety_util.rb:3:# TODO^2: assert ruby version # puts "DEBUG: in #{name} installer, RUBY_VERSION is \"#{RUBY_VERSION}\"."
./lib/installable_skiggety_util.rb:25:    # TODO^2: should we catch exceptions and print them without a full stack trace?
./lib/installable_skiggety_util.rb:43:        install! # TODO^2: catch exception and wrap in: raise "install! command failed for #{self.class}"
./lib/installable_skiggety_util.rb:104:  # TODO^2: RENAME:
./lib/installable_skiggety_util.rb:178:        # TODO^2: we could return something random so it's different each
./lib/installable_skiggety_util.rb:259:    (version_output =~ version_regex).is_a?(Numeric) # TODO^2: update desired vim version
./lib/skiggety-utils.bash:4:# TODO^2: extract & include shelper.bash which checks bash version, and provides utility functions.
./lib/skiggety-utils.bash:6:# TODO^2: . $THIS_DIR/shelper.bash || exit 1
./lib/user_delegation.rb:31:  # TODO^2: maybe shellask isn't always the best way to ask the user a question.  Change calls to this to call the
./start:26:# TODO: this is something similar that I'm also not sure is a good idea: ./bin/start_in_env.bash || exit_with_error "Could not run \"./bin/start_in_env.bash\"" # TODO: don't use relative path # TODO^2: move most things in here, including any interactive stuff
./test/lib/installable_skiggety_util_test.rb:46:  # TODO^2: test call_peer_installer(name)
./test/test_todo.bash:9:SKIGGETY_DEBUG=true # TODO^2: turn debug output off
./version.txt:2:# TODO^2: enforce version number updating?  This might be needed if we know others are using this code, and there's a
./PWD_BIN/ci:7:# TODO^3: possible script renaming--ci means continuos.  This is just the integration part. "review-ci" could become
./PWD_BIN/generate_todo_report:22:# TODO^3: graph this over time, also maybe total votecount and how many votes the topvoted todo has:
./PWD_BIN/install-skiggety-utils:8:# TODO^3: use a lock file so you don't run this twice at once by accident
./README.md:48:    - TODO^3: fix the BUG where you run todo (PWD_BIN/todo) and then cd to test/ and run todo and it complains
./README.md:123:- TODO^3: toy rails site, need a good idea, maybe it can help with information radiating?
./README.md:131:- TODO^3: write a program to abbreviate output for use in the dashboard. You should be able to specify a maximum number of lines and pipe output through it, and it will do something like "head" or "tail" if necessary, but also display information about how many lines were removed/kept/found-in-total
./README.md:136:- TODO^3: try some editable vim macros
./bin/chbs:29:  # TODO^3:  and pass through options for min/max word length (--mwl/--Mwl)
./bin/git-push-new-branch:2:# TODO^3: RENAME this script
./bin/git-ready:30:    # TODO^3: if the remote branch doesn't exist yet, we should skip trying git pull, since it will fail anyway
./bin/review:205:    # TODO^3: maybe instead of using to_i, convert to decimal with 2-3 places:
./bin/today_todo:14:# TODO^3: add a mode to quickly upvote one particular thing, that would call "todo --vote 'substring of my todo line'"
./bin/todo_v0.4:29:# TODO^3: accept piped-in grep output for sorting, like grep does
./bin/todo_v0.4:33:#  TODO^3: in particular '--vote' would be a timesaver, especially if you could use it with today_todo
./bin/todo_v0.4:59:    # TODO^3: how about an argument/mode for the linter that complains about non-compacted todo
./bin/todo_v0.4:166:                # TODO^3: the yellow line should really be everything that's tied for highest votes,
./bin/todo_v0.4:184:# TODO^3: RENAME, remove, move to a new library, or use an existing library?
./bin/vimwhich:7:# TODO^3: accept a "-a" option, and use "which -a" in that case.  This would be useful for "vimwhich
./demo_in_docker:52:# TODO^3: try using docker compose for this:
./installers/basic_prerequisites:76:    # TODO^3: install latest bash and make sure other scripts are compatible...
./installers/rectangle:41:      # TODO^3: If we install a different program similar to rectangle on a different OS, this script should be RENAMEd.
./installers/vim:6:# TODO^3: install and set up vimpager as your pager, but maybe not in this installer
./installers/vim:74:  # TODO^3: maybe move to installable_skiggety_util.rb:
./lib/installable_skiggety_util.rb:107:    # TODO^3: perhaps if the installer contains 'include InstallableSkiggetyUtil', we should call it in the same process
./lib/installable_skiggety_util.rb:181:        #   TODO^3: maybe just use the latest timestamp, from anywhere in the tree?
./lib/installable_skiggety_util.rb:256:  # TODO^3: RENAME?
./test/lib/installable_skiggety_util_test.rb:38:  # TODO^3: write more tests
./.rubocop_todo.yml:9:# TODO^4: Eliminate this file, bit by bit
./PWD_BIN/install-skiggety-utils:71:    # TODO^4: set up a naming convention for installers, because install-vim might make more sense than vim
./PWD_BIN/lint:23:# TODO^4 automatically scan all python files:
./README.md:52:    - (?) How can I make this safer? (TODO^4: consider direnv: "https://direnv.net/docs/hook.html") Put ./users_safeword/../PWD_BIN" in the path instead? make everything in PWD a subcommand of some other command? Come up with some handy way to add/remove it from the path quickly (or add it temporarily)? I put skiggety-utils/PWD_BIN_FIREWALL in your path before ./PWD_BIN if I wanted to block certain things
./README.md:129:- TODO^4: output license summary in interactive programs (like you're supposed to)??
./README.md:130:- TODO^4: commit initial skigg-utils, to get to parity with what I already like to use
./README.md:133:- TODO^4: consider supporting other shells:
./README.md:134:  - TODO^4: consider supporting zsh
./README.md:137:- TODO^4: set up a git hook system so you can add multiple scripts. For example, I'd like to block commits that include
./README.md:143:- TODO^4: music rotator thingy (Neighbor Shawn might beta test)
./bin/abbreviate:5:# and run tail otherwise.  TODO^4: # Maybe could RENAME it to 'tailmax', 'tail-verbose', or something?
./bin/git-attempt-checkout:4:#   TODO^4: maybe set up git tab completion first ( see: https://apple.stackexchange.com/questions/55875/git-auto-complete-for-branches-at-the-command-line )
./bin/git-ready:19:    # TODO^4: just exit 0 right here unless there are changes staged
./bin/review:82:    start_wake_on_filesystem_change # TODO^4: this should depend on a command line flag
./bin/shellask:49:# TODO^4: can I RENAME these aliases to something more convenient? I mean "yes_shellask"? seriously?:
./bin/today_todo:122:    # TODO^4: add NOW count to graph:
./bin/today_todo:142:    # TODO^4: add NOW count to this output?:
./bin/today_todo:146:        # TODO^4: graph how many are done each day
./bin/todo_v0.4:113:    interactive = True # TODO^4: detect if output is to a terminal
./bin/todo_v0.4:147:                        # TODO^4: write more efficiently (all changes from one file at once):
./bin/todo_v0.4:182:    # TODO^4: print summary with TODO count, maybe a vote count
./bin/todo_v0.4:240:  # TODO^4: todo should accept a path ( to a file or directory) to use in place of "." for grep.
./bin/vimwhich:36:    # TODO^4: create $destination file from template if it doesn't exist and mark it executable.
./installers/basic_prerequisites:81:        # TODO^4: un-loop, it's too slow:
./installers/basic_prerequisites:96:    #   TODO^4: ...but first, make sure you have learned how to make version hacks play nice with them
./installers/basic_prerequisites:97:    #   TODO^4: ...but first, reorganize this script so rbenv and pyenv happen before ruby and python
./installers/git:34:    #   TODO^4: thinking about this further, asking the user to install the latest git would fit in perfectly with the
./installers/skiggety.bash:35:    # TODO^4: check for marker file to avoid re-running, like in './basic_prerequisites'
./installers/vim:24:  # TODO^4: we need some way of watching other files.  If they are newer than our marker file, we need a reinstall.
./lib/skiggety-utils.bash:166:    echo -ne "\r" # TODO^4: cut this bs out and do it properly, in some places this looks like a newline
./start:29:# help_with_skiggety_utils # TODO^4: RENAME, test/implement something to show the help system if I do more with it.
./PWD_BIN/ci:24:# TODO^5: accumulate error if any local changes are found, i.e. "maybe you want to run 'dev' instead of 'ci'? Do you want
./PWD_BIN/ci:31:# TODO^5: ensure that the mere act of running ci doesn't cause local changes.  I'm looking at PWD_BIN/lint .
./PWD_BIN/dashboard:11:# show diff with old mac files: # TODO^5: work on this diff:
./PWD_BIN/install-skiggety-utils:13:# TODO^5: careful/tentative/untrusting mode, ask user for confirmation as you go.  Might make it easier for others.  It
./PWD_BIN/lint:6:# TODO^5: run shellcheck
./PWD_BIN/lint:24:# TODO^5: get in the habit of keeping everything clean and then use accumulate_error here:
./bin/chbs:12:# TODO^5 Consider making a website that runs this script in the browswer, using https://opalrb.com/
./bin/review:38:# TODO^5: Would it be smart to have a cron job that runs 'pkill review' every day at ~7pm on my work laptop? Or should I
./bin/todo_v0.4:4:# TODO^5: break out the next version into it's own project/repo
./demo_in_docker:48:# TODO^5: IMPLEMENT and UNCOMMENT: echo "You can run 'TODO' in another terminal to connect to this container, but the container will stop when this session ends"
./installers/git:41:    # TODO^5: what's with the sporadic syntax error sometime after this?
./lib/installable_skiggety_util.rb:36:        # TODO^5: but what if it is apparently installed, but marked for an old hash (installer has changed), we should
./lib/installable_skiggety_util.rb:146:  # TODO^5: consider changing the naming convention in the installers directory to avoid the
./lib/skiggety-utils.bash:84:# TODO^5: consistent debug/echo function names
./PWD_BIN/install-skiggety-utils:17:# TODO^6: move to bin? I need to make sure I can run it independently of $PWD, though
./README.md:124:- TODO^6: some tools for setting up information radiators
./bin/default_dashboard:4:# TODO^6: consider renaming or extracting to git-default-dashboard or git-dashboard considering what this script actually does
./bin/git-attempt-checkout:3:# TODO^6: RENAME this script.  How about "git-findout"?
./bin/git-pretty-pull:3:# TODO^6: maybe RENAME, e.g. 'git-pull-verbose'
./bin/pretty_sleep:30:# TODO^6: DELETE this script once you're sure it's not used
./bin/today_todo:6:# TODO^6: RENAME? ("todo-today"?, "todoy")
./bin/today_todo:64:        vim -o $files_to_open '+/\.\.\.' # TODO^6: here and elsewhere, use $EDITOR, not vim
./installers/basic_prerequisites:95:    # TODO^6: consider replacing rbenv and pyenv with asdf
./README.md:47:    - TODO^7: by the way, figure out how to tack one git repo on to another so you don't have ./PWD_BIN always showing up in the
./bin/review:35:# TODO^7: a control key to wake it up and make it refresh immediately (accept a control character or signal to refresh
./bin/review:42:# TODO^7: BUG make sure child processes get killed when you use CTRL + C on this program to stop it
./bin/shellask:26:# TODO^7: figure out why this script occasionally fails to set the prompt.  It seems to still get as far as producing a
./bin/todo_v0.4:5:#   TODO^7: RENAME this (with Kevin), or at least the next version, to something a bit more unique
./installers/vim:62:    # TODO^7: learn to use nerdcommenter:
./PWD_BIN/lint:3:# TODO^8: make this read-only by default, split the write version into another script if necessary
./PWD_BIN/lint:4:#   TODO^8: I think the way to handle this is to support a '-w', '--fix', '-n' or '--ro' option
./README.md:122:  - TODO^11: ...rewrite todo in rust with parallelization (with Kevin), but after [rust koans](https://github.com/crazymykl/rust-koans)
